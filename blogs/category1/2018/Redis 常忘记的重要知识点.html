<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis 常忘记的重要知识点 | 麻辣烫不加辣</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="头标.png">
    <meta name="description" content="""his is myblog">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.0ab6a768.css" as="style"><link rel="preload" href="/assets/js/app.faa17523.js" as="script"><link rel="preload" href="/assets/js/3.d40710ef.js" as="script"><link rel="preload" href="/assets/js/1.7e378398.js" as="script"><link rel="preload" href="/assets/js/26.95fcf31d.js" as="script"><link rel="prefetch" href="/assets/js/10.66a2476e.js"><link rel="prefetch" href="/assets/js/11.fb7d12d0.js"><link rel="prefetch" href="/assets/js/12.a9e9c0c2.js"><link rel="prefetch" href="/assets/js/13.6a93ecf1.js"><link rel="prefetch" href="/assets/js/14.be681b15.js"><link rel="prefetch" href="/assets/js/15.c3f94c5e.js"><link rel="prefetch" href="/assets/js/16.553281df.js"><link rel="prefetch" href="/assets/js/17.dfe6141d.js"><link rel="prefetch" href="/assets/js/18.1751d85f.js"><link rel="prefetch" href="/assets/js/19.f2e0e249.js"><link rel="prefetch" href="/assets/js/20.e940d874.js"><link rel="prefetch" href="/assets/js/21.5f7d4709.js"><link rel="prefetch" href="/assets/js/22.bb3d4add.js"><link rel="prefetch" href="/assets/js/23.f36bc449.js"><link rel="prefetch" href="/assets/js/24.5020b4da.js"><link rel="prefetch" href="/assets/js/25.8c61ea18.js"><link rel="prefetch" href="/assets/js/27.b3500f6e.js"><link rel="prefetch" href="/assets/js/28.bd6e122c.js"><link rel="prefetch" href="/assets/js/29.6196297d.js"><link rel="prefetch" href="/assets/js/30.e10cee0b.js"><link rel="prefetch" href="/assets/js/31.8e89e0e4.js"><link rel="prefetch" href="/assets/js/32.4fffa058.js"><link rel="prefetch" href="/assets/js/33.bfd6421c.js"><link rel="prefetch" href="/assets/js/34.dd051c60.js"><link rel="prefetch" href="/assets/js/35.22b02e0e.js"><link rel="prefetch" href="/assets/js/36.6d34fd45.js"><link rel="prefetch" href="/assets/js/37.51aa0fff.js"><link rel="prefetch" href="/assets/js/38.dcd289ce.js"><link rel="prefetch" href="/assets/js/39.70de9eaf.js"><link rel="prefetch" href="/assets/js/4.51cbaa00.js"><link rel="prefetch" href="/assets/js/40.88d489fb.js"><link rel="prefetch" href="/assets/js/41.bcbda0f8.js"><link rel="prefetch" href="/assets/js/42.54f797c2.js"><link rel="prefetch" href="/assets/js/43.3f32ba16.js"><link rel="prefetch" href="/assets/js/44.251dd9e6.js"><link rel="prefetch" href="/assets/js/45.611cf99a.js"><link rel="prefetch" href="/assets/js/46.38fcf7e1.js"><link rel="prefetch" href="/assets/js/47.d3ba7f51.js"><link rel="prefetch" href="/assets/js/48.8c9e1a9f.js"><link rel="prefetch" href="/assets/js/49.02338805.js"><link rel="prefetch" href="/assets/js/5.78f022ed.js"><link rel="prefetch" href="/assets/js/50.192722b5.js"><link rel="prefetch" href="/assets/js/51.21bdb02f.js"><link rel="prefetch" href="/assets/js/52.48b4c347.js"><link rel="prefetch" href="/assets/js/53.993caab3.js"><link rel="prefetch" href="/assets/js/54.997ced4c.js"><link rel="prefetch" href="/assets/js/55.5ede185b.js"><link rel="prefetch" href="/assets/js/56.9636df42.js"><link rel="prefetch" href="/assets/js/57.3a9aeb00.js"><link rel="prefetch" href="/assets/js/58.31744a2f.js"><link rel="prefetch" href="/assets/js/59.d1b7fda5.js"><link rel="prefetch" href="/assets/js/6.1dbfeed7.js"><link rel="prefetch" href="/assets/js/60.a4895531.js"><link rel="prefetch" href="/assets/js/61.c02db56a.js"><link rel="prefetch" href="/assets/js/62.2e71a0a3.js"><link rel="prefetch" href="/assets/js/63.90234e4b.js"><link rel="prefetch" href="/assets/js/64.9181ec64.js"><link rel="prefetch" href="/assets/js/65.4ff48956.js"><link rel="prefetch" href="/assets/js/66.1d61bfe7.js"><link rel="prefetch" href="/assets/js/67.8708fa10.js"><link rel="prefetch" href="/assets/js/68.259b39a4.js"><link rel="prefetch" href="/assets/js/69.5ec8555c.js"><link rel="prefetch" href="/assets/js/7.613fbb1a.js"><link rel="prefetch" href="/assets/js/70.e1613f74.js"><link rel="prefetch" href="/assets/js/71.2c17a996.js"><link rel="prefetch" href="/assets/js/8.8cfbbdc8.js"><link rel="prefetch" href="/assets/js/9.35d202ea.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0ab6a768.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-5bb33761><div data-v-5bb33761><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-5bb33761 data-v-5bb33761><h3 class="title" data-v-59e6cb88>麻辣烫不加辣</h3> <p class="description" data-v-59e6cb88>&quot;&quot;his is myblog</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>考小拉</span>
          
        <span data-v-59e6cb88>2017 - </span>
        2024
      </a></span></div></div> <div class="hide" data-v-5bb33761><header class="navbar" data-v-5bb33761><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/1e64b7cc830c848fe6800ffc14ab1d2.jpg" alt="麻辣烫不加辣" class="logo"> <span class="site-name">麻辣烫不加辣</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      目录
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/学习小记/" class="nav-link"><i class="undefined"></i>
  学习小记
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文件
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/theme-reco/" class="nav-link"><i class="undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-5bb33761></div> <aside class="sidebar" data-v-5bb33761><div class="personal-info-wrapper" data-v-1fad0c41 data-v-5bb33761><img src="/398f8e744c4ae5e78367ae601358966f_1.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    考小拉
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>57</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>33</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      目录
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/学习小记/" class="nav-link"><i class="undefined"></i>
  学习小记
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文件
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/theme-reco/" class="nav-link"><i class="undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-5bb33761><h3 class="title" data-v-59e6cb88>Redis 常忘记的重要知识点</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>考小拉</span>
          
        <span data-v-59e6cb88>2017 - </span>
        2024
      </a></span></div></div> <div data-v-5bb33761><div data-v-5bb33761><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Redis 常忘记的重要知识点</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>考小拉</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>9/28/2023</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>Redis</span><span class="tag-item" data-v-8a445198>秋招</span></i></div></div> <div class="theme-reco-content content__default"><p>都知道用的 <code>Redis</code> 比较少，但是作为后端非常重要的一个中间件，必须要懂的；今天就想来总结一点 <code>Redis</code> 的高频的八股文吧。</p> <p>下文借鉴 <a href="https://juejin.cn/post/7094237187343908900#heading-65" target="_blank" rel="noopener noreferrer">三分恶<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 以及 <a href="https://xiaolincoding.com/redis/" target="_blank" rel="noopener noreferrer">小林coding<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="基础知识"><a href="#基础知识" class="header-anchor">#</a> 基础知识</h2> <ul><li><p>基本数据结构</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100e87a7da6149248c4604684b20a492~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><code>String</code></p> <p>字符串类型是最基础的数据类型，其 value 可以是字符串（简单字符串，复杂字符串例如 <code>JSON</code>、<code>XML</code>），数字（整数、浮点数），甚至是二进制（图片、音频、视频），但是有一定的限值（512M）</p> <p>使用场景：</p> <ul><li>缓存功能（下拉刷新功能）</li> <li>计数（浏览量）</li> <li>共享 <code>session</code> （分布式系统下采取这个方案来使得 <code>session</code> 一致）</li> <li>分布式锁（<code>setNx()</code>）</li></ul> <p><code>hash</code></p> <p>哈希类型是指<strong>键值本身又是一个键值对结构</strong></p> <p>应用场景：</p> <ul><li>购物车</li> <li>缓存对象</li></ul> <p><code>list</code></p> <p>列表（<code>list</code>）类型是用来<strong>存储多个有序的字符串</strong>，列表是一种比较灵活的数据结构，可以充当栈和队列的角色</p> <p>使用场景：</p> <ul><li>消息队列</li> <li>文章列表</li></ul> <p><code>set</code></p> <p>集合 set 类型也是用来保存多个元素的，但是和列表不一样，集合中不允许有重复的元素，并且集合中的元素是无序的；</p> <p>使用场景：</p> <ul><li>共同关注好友类型</li> <li>点赞</li></ul> <p><code>zset</code></p> <p>这个是<strong>有序集合</strong>，存储的元素是有序的；但是<strong>他和列表使用的索引下标作为排序依据不同</strong>，他给<strong>每个元素设置一个权重（<code>score</code>）作为排序的依据</strong>。</p> <p>使用场景：</p> <ul><li>用户点赞统计</li> <li>用户排序</li></ul></li> <li><p><code>Redis</code> 为什么这么快呢？</p> <ul><li><p>完全基于内存的操作</p></li> <li><p>使用的是 单 Reactor 单线程，避免了线程切换和竞态产生的消耗，这个可以<a href="https://mltbjl.github.io/blogs/category1/2018/OS%20%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.html#%E4%BB%80%E4%B9%88%E6%98%AF-dma-%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener noreferrer">参考一下这篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>基于非阻塞的 IO 多路复用机制</p> <p><a href="https://mltbjl.github.io/blogs/category1/2018/OS%20%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.html#%E4%BB%80%E4%B9%88%E6%98%AF-dma-%E6%8A%80%E6%9C%AF" target="_blank" rel="noopener noreferrer">参考一下这个文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>可以举个例子</p> <p>这里最重要就是理解 <code>epoll</code> 模式：老师在讲台上等，谁解答完谁举手；这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续在讲台上等，此时E、A又举手，然后再去处理E、A。</p></li> <li><p>C语言实现的，使用优化过的数据结构</p></li></ul></li> <li><p><code>Redis</code> 真的是单线程？</p> <p>GPT 回答：<code>Redis</code> 是使用单线程（一个主线程）来处理所有客户端请求的，但是它使用了非阻塞的 <code>IO</code> 多路复用以及 单<code>Reactor</code>单线程模式进行处理的，通过异步处理多个客户端请求和并行执行多个操作，从而实现高性能的。</p> <p>但是 <code>Redis</code> 整个中间件<strong>不是单线程的</strong>，因为还有后台线程进行<strong>处理清理脏数据、无用链接的释放、大 <code>Key</code> 的删除等操作</strong>。</p></li> <li><p><code>Redis</code> 6.0 使用多线程处理客户端请求？</p> <p>这里引用了多线程来<strong>处理数据的读写和协议解析</strong>，但是 <code>Redis</code> <strong>执行命令还是单线程</strong>的。</p></li></ul> <h2 id="缓存篇"><a href="#缓存篇" class="header-anchor">#</a> 缓存篇</h2> <p>经典的缓存击穿、缓存穿透、缓存雪崩</p> <ul><li><p>缓存击穿</p> <p>什么是缓存击穿问题？就是<strong>一个并发访问量比较大的 key 在某个时间过期，导致所有的请求直接打在了 DB 上</strong>。</p> <p>如果单单只考虑 <code>Redis</code> 层的问题是不够的：</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ce2521931244cf4b172a66280c3a4c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>①加锁更新，请求查询A，发现缓存中没有存在，对 A 这个 <code>key</code> 进行加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中进行获取了。</p> <p>②将过期时间组合写在 <code>value</code> 中，通过异步的方式进行不断刷新过期时间；</p> <p>用 <code>Jemeter</code> 压测，500w数据的表，聚簇索引去查 <code>QPS</code>（每秒能够响应的请求） 7w，普通索引是2700多， 这个问题是高并发架构问题，不是 <code>Redis</code> 本身的问题</p> <ol><li>正确评估系统的容量 和 业务的慢查询</li> <li>你需要知道所有用缓存的场景 当我们的key 缓存失效的时候，你的数据库能承载的数据的并发是多少   用查询是多少耗时不用是多少耗时</li> <li>查询一般排除网络因素的情况下，保持在 200ms 是可观的</li> <li>缓存监控呢？</li> <li>系统降级熔断策略？</li> <li>最重要的做好一些保底方案</li></ol></li> <li><p>缓存雪崩</p> <p>缓存学崩就是同一个时间内大量的 <code>key</code> 失效了或者是服务宕机，这样导致的后果就是大量的请求进来直接打到 DB 上，可以导致整个系统崩溃。</p></li> <li><p>缓存穿透</p> <p>指的是查询缓存和数据库中都不存在的数据，这样每次请求直接打到数据库，就好像缓存不存在一样。</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1caeaf7f70d24602873aab87bd094af3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>缓存穿透有两种原因：①本身业务代码有问题；②恶意攻击，爬虫造成空命中；</p> <p>解决方法：</p> <ul><li><p>缓存空值或者是默认值</p> <p>缓存空值有两个问题：</p> <ol><li>空值做了缓存，意味着缓存层存了更多的键，比较有效的方法就是给这类数据进行设置一个较短的时间，让其自动过期剔除；</li> <li>缓存层和存储层会有一段时间的数据不一致；例如过期时间设置为五分钟，在五分钟的时候存储层真的添加的这个数据，但是查询的时候还是返回的是空值，就会导致数据不一致了，这个时候可以利用消息队列或者其他异步的方式进行清理缓存中的空对象。</li></ol></li> <li><p>布隆过滤器</p> <p>在存储和缓存之前，加一个布隆过滤器，做一层过滤； <a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e07aced98ad4ef49bde2bb0402284b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>这里需要了解一下这个<strong>布隆过滤器的原理</strong>：</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f04d7a0799f343dc88e9a1d3f3226e8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>是一个<strong>连续的位图数据结构</strong>，每个存储位存储的都是 0 或者 1，来标识数据是否存在；</p> <p>如果判断缓存 <code>key</code> 存在，K 个 <code>Hash</code> 函数会将这个 <code>key</code> 映射在 <code>bit</code> 列表上的 K 个点，判断是不是1：</p> <ul><li>如果全不是1，那么 <code>key</code> 不存在；</li> <li>如果都是1，也只是表示 <code>key</code> 可能存在；</li></ul> <p>缺点：</p> <ul><li>判断元素的时候有一定的几率是错误的，毕竟哈希函数有一定的碰撞机率；</li> <li>不支持删除元素。</li></ul></li></ul></li> <li><p>数据一致性问题</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb5ee0b09d6744beaf11d3ceccaa8ce3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>根据 <code>CAP</code> 理论，<strong>在保证可用性和分区容错性的前提下，无法保证一致性</strong>，所以缓存和数据库的绝对一致是不可能实现的，只能尽可能<strong>保存缓存和数据库的最终一致性</strong>。</p> <p>首先我们需要确立一个思想，<strong>删除缓存而不是更新缓存。</strong></p> <p><strong>为什么</strong> 缓存更新需要耗费资源，直接删除，用的时候从数据库中获取然后写入缓存中，省性能。</p> <p><strong>先更新数据库，再删除缓存</strong></p> <p>删除失败怎么办？那从缓存读到的数据还是脏数据啊？ <a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d38a0fcf49004669b7ff0cdf7a6b6149~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p>消息队列重试机制 <a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c370cf9b5a4444a05bb7501ea7d4dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>如果删除缓存失败，向消息队列发送异步消息，把删除失败的 <code>key</code> 放进去，消费消息队列，获取要删除的 <code>key</code> ，然后去重试删除；</p> <p>但是缺点是，好好的业务，引入新的中间件，复杂度提升了。。。</p></li> <li><p>监听 <code>binlog</code> 异步删除 <a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b0b6efa4c64babbc834149b6e0f36a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>利用一个服务（阿里的 <code>canal</code>）去监听数据库的 <code>binlog</code>，获取需要操作的数据；</p> <p>然后另外一个服务获取订阅程序传来的信息，进行缓存删除操作；</p> <p>但是还是需要消息队列进行兜底。。。</p></li></ul> <p><strong>先删除缓存，再更新数据库</strong></p> <p>也会出现这个一致性问题。</p> <p>并发情况下，先删除缓存，再更新数据库，此时数据库还未更新成功，这时候有其他线程读取缓存读取不到就去数据库中读取到了旧值，这时候就会出现缓存不一致了。 <a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abb14952f1574629baf244adf760ef8c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p>延迟双删 <a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29e32dda00ba465ba6cd1ab45d98dc11~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>在删除缓存，更新数据库之后，休眠一段时间（但是这个就很难琢磨），再次删除缓存。这个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这个一段时间内【从数据库读取数据，再把缺失的缓存写入缓存】的操作，然后请求 A 睡眠完，再删除缓存；</p> <p>延时双删，就把缓存里缓存的旧值给删除了；</p> <p>再有请求进来，就是读取数据库里的新值，再把新值保存到缓存中。（失败了怎么办？重试。。。。）</p> <p>关于删除，还有一个兜底的方案 ---- <strong>设置缓存过期时间</strong>，这样的话脏数据总有过期的时时候嘛不至于一直不一致。小林 codig 建议使用【先更新数据库，再删除缓存】</p></li></ul></li></ul> <h2 id="持久篇"><a href="#持久篇" class="header-anchor">#</a> 持久篇</h2> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d775dae96eef4d7ca15598afa37fc72f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p><code>AOF</code></p> <p><code>append only file</code>：以独立日志的方式记录每次写命令，重启时再启动执行 <code>AOF</code> 文件中的命令以达到恢复数据的目的。<code>AOF</code> 的主要作用是解决数据持久化的实时性，是 <code>Redis</code> 持久化的主流方式。</p> <p><code>AOF</code>：当主进程执行完操作命令后，会紧接着执行将命令写入到 <code>AOF</code> 文件的操作；这里有三种写回策略，分别是 <code>Always</code>、<code>No</code>、<code>EverySec</code>；写回的过程是：首先主进程将命令写入到 <code>server.aof_buf</code> 文件中，然后通过 <code>write()</code> 系统调用将数据拷贝到 <code>AOF</code> 文件中，然后再将数据拷贝到这个内核缓冲区中；<strong>由内核缓冲区来决定啥时候写入磁盘；</strong> <img src="https://cdn.xiaolincoding.com//mysql/other/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" alt="img"></p> <p><a href="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a.png" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a.png" alt="img"></p> <p>为了防止这个文件过大，<code>AOF</code> 采用这个重写机制来进行压缩文件，防止 <code>Redis</code> 重启时，时间过久；同时 <code>AOF</code> 的重写操作不能在主线程进行的，需要使用到<strong>写时复制</strong>技术；</p></li> <li><p><code>RDB</code></p> <p><code>RDB</code> 持久化就是将当前进程数据生成快照保存在硬盘的过程，触发 <code>RDB</code> 持久化过程分为手动触发和自动触发</p> <p>手动触发对应 <code>save</code> 和 <code>bgsave</code>：一个阻塞主线程一个不阻塞 <a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7878881b559d43ce8423843a1d4f813b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>重点了解一下这个 <code>bgsave</code>：我们执行 <code>fork</code> 操作创建子线程，<code>RDB</code> 持久化过程由子进程负责，完成后自动结束，阻塞只发生在 <code>fork</code> 阶段，时间短；</p></li> <li><p><code>AOF</code> 和 <code>RDB</code> 的混合</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c23f6e65c143ce889519136dd46295~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>将 <code>RDB</code> 文件的内容和增量的 <code>AOF</code> 日志文件放在一起，这里的 <code>AOF</code> 日志不再是全量的日志，而是 <strong>自持久化（也就是 <code>Redis</code> 开始执行持久化操作的时刻）开始到持久化结束（<code>Redis</code> 将数据完全写入 <code>AOF</code> 文件并完成持久化时刻）</strong> 的这段时间发生的增量 <code>AOF</code> 日志，通常这部分的 <code>AOF</code> 日志很小。</p></li> <li><p><code>RDB</code> 和 <code>AOF</code> 如何选择？</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5cc20579aa14cde9afbbceaab5125a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>都要使用，当 <code>Redis</code> 启动的时候优先载入 <code>AOF</code> 文件来恢复原始数据，因为 <code>AOF</code> 文件保存的数据比 <code>RDB</code> 完整；</p> <p>接收几分钟的数据丢失可以只使用 <code>RDB</code> 持久化</p> <p>不建议只使用 <code>AOF</code>，因为 <code>RDB</code> 非常适用文件数据的备份，并且 <code>RDB</code> 恢复数据的速度比 <code>AOF</code> 快；</p></li></ul> <h2 id="数据结构篇"><a href="#数据结构篇" class="header-anchor">#</a> 数据结构篇</h2> <p>重点是<strong>跳表</strong></p> <p><a href="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.png" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><code>Redis</code> 中只有 <code>Zset</code> 对象的底层实现用到了跳表，跳表的优势就是能支持平均<code>O(logN)</code> 复杂度的节点查找。</p> <p>跳表的数据结构：</p> <div class="language-C line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>
    <span class="token comment">//Zset 对象的元素值</span>
    sds ele<span class="token punctuation">;</span>
    <span class="token comment">//元素权重值</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    <span class="token comment">//后向指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>
  
    <span class="token comment">//节点的level数组，保存每层上的前向指针和跨度</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><code>Zset</code> 对象同时保存【元素】和【元素的权重】，节点的权重是一个 <code>double</code> 类型的浮点数，跳跃表中所有的节点都是按照<strong>这个权重从小到大来排序的</strong>；前向指针和后向指针都是为了方便查询；【跨度】作用是：计算这个节点在跳表中的排位，实际我也不知道他是干啥的哈哈。</p> <ul><li><p>查询过程</p> <p>直接看图就行，从最高层开始查找，找不到就到下一个层级依次找即可，可以借助查找【元素：abcd，权重：4】的节点来进行学习。</p></li> <li><p>为什么用跳表而不是<strong>红黑树/平衡树</strong>呢？</p> <p>第一点，红黑树/平衡树都是一个自适应的平衡操作；但是对于跳表来说只需要局部的调整即可，不用涉及到整棵树的操作；</p> <p>第二点，实现难度来说跳表更加简单看起来也很直观。</p> <p>其实本质也是为了查询而已。</p></li></ul> <h2 id="运维篇"><a href="#运维篇" class="header-anchor">#</a> 运维篇</h2> <ul><li><p><code>Redis</code> 的过期数据（具体说就是过期 <code>key</code> ）回收策略有哪些？</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c19f8f9758b3464fa36283d3695aa3cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>惰性删除：惰性删除指的是当我们查询 <code>key</code> 的时候才对 <code>key</code> 进行处理，如果达到了过期时间则进行删除；显然<strong>缺点就是</strong>：假如这些过期的 <code>key</code> 一直没有被访问，那么他就一直无法被删除，而且一直占用内存的；</p> <p>定期删除：<code>Redis</code> 会每隔一段时间对数据库做一次检查，删除里面的过期 <code>key</code>，由于不可能对所有 <code>key</code> 去做轮询来删除，所以 <code>Redis</code> 会每次随机取一些 <code>key</code> 去做检查和删除。</p></li> <li><p><code>Redis</code> 有哪些内存溢出控制？</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/048df4c55dc04a4486641626fa7ed088~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>如何记忆？两个维度 四个方面</p> <p><strong>两个维度</strong>：<code>LRU</code> 和 <code>LFU</code></p> <p><strong>四个方面</strong>：<code>ttl</code>（准备过期键）、<code>LRU</code>（最近最少使用）、<code>LFU</code>（频率最少使用）、<code>random</code>（随机的键）</p> <p><code>LRU</code> 算法如何实现？</p> <p><code>LRU</code> 是 Least Recently Used 翻译为<strong>最近最少使用</strong>。</p> <p>传统的 <code>LRU</code> 是基于 <code>HashMap</code> 和 双向链表来实现的；有弊端：用链表管理缓存数据，有空间开销；当数据被访问时，需要将链表上的数据移动到头端，如果有大量数据被访问，带来很多链表上移动的操作，耗时；</p> <p><code>Redis</code> 实现 <code>LRU</code> 算法：<strong>实现方式是在 <code>Redis</code> 的对象结构中添加了一个额外的字段，用于记录此数据的最后一次的访问时间。</strong></p> <p>当 <code>Redis</code> 进行内存淘汰的时候，会使用<strong>随机采用的方式进行淘汰数据</strong>，随机抽取几个数据，然后<strong>淘汰最久没有使用的那一个</strong>。</p> <p>但是 <code>LRU</code> 算法<strong>无法解决缓存污染的问题</strong>；比如应用一次性读取了很多数据，而这些数据只会被读取一次，那么这些数据就会留存在 <code>Redis</code> 缓存中一段时间，造成缓存污染。</p> <p><code>LFU</code> 算法如何实现？</p> <p><code>LFU</code> 是 Least Frequently Used 翻译为<strong>最近最不常用</strong>；</p> <p><code>LFU</code> 是根<strong>据数据访问的次数（应该是频次）来进行淘汰数据的</strong>，核心思想是：“如果数据过去被访问多次，那么将来被访问的频率也会很高。”</p> <p><code>Redis</code> 如何实现呢？</p> <p><code>LFU</code> 相比于 <code>LRU</code> 算法，多记录了【数据的访问频次】的信息；</p> <div class="language-C line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      
    <span class="token comment">// 24 bits，用于记录对象的访问信息</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span><span class="token number">24</span><span class="token punctuation">;</span>  
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>Redis</code> 对象头的 <code>lru</code> 字段，<code>LRU</code> 算法中和 <code>LFU</code> 算法中的意义不一样。</p> <p><a href="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/lru%E5%AD%97%E6%AE%B5.png" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>在 <code>LRU</code> 算法中</strong>，<code>Redis</code> 对象头中的 <strong><code>lru</code> 字段是用来记录 <code>key</code> 的访问时间戳的</strong>，因此在 <code>LRU</code> 模式下，<code>Redis</code> 可以根据对象头的 <code>lru</code> 字段记录的值，<strong>来比较最后一次的 <code>key</code> 的访问时间大小</strong>，<strong>从而淘汰最久未被使用的 key；</strong></p> <p><strong>在 <code>LFU</code> 算法中</strong>，<code>Redis</code> 对象头中的 <code>lru</code> 字段分两段存储，高16位（<code>ldt</code>）<strong>存储 <code>key</code> 的访问时间戳</strong>，低16位（<code>logc</code>）<strong>存储 <code>key</code> 的访问频次</strong>，值越小证明使用频率越低，越容易淘汰；在每次 <code>key</code> 被访问的时候，会对 <code>logc</code> 做一个衰减的操作，<strong>衰减的值跟前后访问时间的差距有关系</strong>，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 <code>LFU</code> 算法是<strong>根据访问频率来淘汰数据的，而不是访问次数</strong>。</p></li></ul> <h2 id="场景思考"><a href="#场景思考" class="header-anchor">#</a> 场景思考</h2> <ul><li><p>假如 <code>Redis</code> 里头有 1 亿个 <code>key</code> ，其中有 10w 个 <code>key</code> 是以某个固定的已知的前缀开头的，如何将它们全部找出来？</p> <p>使用 <strong><code>keys</code></strong> 指令可以扫出指定模式的 <code>key</code> 列表，但是要注意 <code>keys</code> 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才会恢复；</p> <p>所以我们用 <strong><code>scan</code> 指令</strong>，<code>scan</code> 指令可以<strong>无阻塞（异步</strong>提取指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重即可，但是整体花费的时间会长一些。</p></li> <li><p>大 key 问题</p> <ul><li><p>什么是大 <code>key</code> ？</p> <p>单个简单的 key 存储的 <code>value</code> 很大，<code>size</code> 超过 10KB；</p> <p><code>hash</code>、<code>set</code>、<code>zset</code>、<code>list</code> 中存储过多的元素（以万为单位）。</p></li> <li><p>大 <code>key</code> 会有什么问题？</p> <p>客户端耗时增加，甚至超时；</p> <p>对大 <code>key</code> 进行 <code>IO</code> 操作严重影响带宽和 <code>CPU</code></p> <p>删除 <code>Key</code> 的时候会有阻塞</p></li> <li><p>如何找到大 <code>Key</code>？</p> <p><code>bigKeys</code> 命令：使用 <code>bigKeys</code> 命令以遍历的方式分析 <code>Redis</code> 实例中的所有 <code>Key</code>，并返回整体统计信息与每个数据中的 <code>TOP1</code> 的大 Key</p> <p><code>redis-rdb-tools</code>：<code>redis-rdb-tools</code> 是由 <code>Python</code> 写的用来分析 <code>Redis</code> 的 <code>rdb</code> 快照文件用的工具，它可以把 <code>rdb</code> 快照文件生成 <code>json</code> 文件或者生成报表用来分析 <code>Redis</code> 的使用详情。</p></li> <li><p>如何避免大 <code>Key</code>？</p> <p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8074768d2684898847122267c574608~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" target="_blank" rel="noopener noreferrer">图片<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p>删除大 Key</p> <p>反正核心不要使用阻塞主线程的命令就行了，用异步的线程进行删除；使用 <code>UNLINK</code> 命令安全进行删除大 key，不要使用 <code>DEL</code> 命令；</p></li> <li><p>压缩和拆分 Key</p> <p>当 <code>value</code> 是 <code>String</code> 时，可以采取 序列化或者压缩算法 将 <code>key</code> 大小控制在合理范围内，但是会带来时间上的消耗；</p> <p>如果压缩之后 <code>value</code> 还是大 <code>key</code> ，则需要进行拆分，将一个大 <code>key</code> 分为不同的部分，记录每个部分的 <code>key</code>，使用 <code>multiget</code> 等操作实现事务获取；</p> <p>当 <code>value</code> 是 <code>list</code> 或者 <code>set</code> 集合类型时，可以根据不同类型的数据规模进行分片，不同的元素计算后分到不同的片。</p></li></ul></li></ul></li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-ac050c62><li class="level-2" data-v-ac050c62><a href="/blogs/category1/2018/Redis%20%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#基础知识" class="sidebar-link reco-side-基础知识" data-v-ac050c62>基础知识</a></li><li class="level-2" data-v-ac050c62><a href="/blogs/category1/2018/Redis%20%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#缓存篇" class="sidebar-link reco-side-缓存篇" data-v-ac050c62>缓存篇</a></li><li class="level-2" data-v-ac050c62><a href="/blogs/category1/2018/Redis%20%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#持久篇" class="sidebar-link reco-side-持久篇" data-v-ac050c62>持久篇</a></li><li class="level-2" data-v-ac050c62><a href="/blogs/category1/2018/Redis%20%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#数据结构篇" class="sidebar-link reco-side-数据结构篇" data-v-ac050c62>数据结构篇</a></li><li class="level-2" data-v-ac050c62><a href="/blogs/category1/2018/Redis%20%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#运维篇" class="sidebar-link reco-side-运维篇" data-v-ac050c62>运维篇</a></li><li class="level-2" data-v-ac050c62><a href="/blogs/category1/2018/Redis%20%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#场景思考" class="sidebar-link reco-side-场景思考" data-v-ac050c62>场景思考</a></li></ul></main></div> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.faa17523.js" defer></script><script src="/assets/js/3.d40710ef.js" defer></script><script src="/assets/js/1.7e378398.js" defer></script><script src="/assets/js/26.95fcf31d.js" defer></script>
  </body>
</html>
