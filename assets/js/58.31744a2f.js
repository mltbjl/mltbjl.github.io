(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{447:function(_,v,t){"use strict";t.r(v);var e=t(2),o=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("本文参考 "),v("a",{attrs:{href:"https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93",target:"_blank",rel:"noopener noreferrer"}},[_._v("小林coding"),v("OutboundLink")],1),_._v(" 以及 "),v("a",{attrs:{href:"https://juejin.cn/post/7061954933284667429#heading-17",target:"_blank",rel:"noopener noreferrer"}},[_._v("三分恶"),v("OutboundLink")],1)]),_._v(" "),v("h2",{attrs:{id:"http"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[_._v("#")]),_._v(" HTTP")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("[ ] 301、302、304状态码是啥含义，区别")])]),_._v(" "),v("li",[v("p",[_._v("[ ] HTTP的 get 和 post 请求区别")])]),_._v(" "),v("li",[v("p",[_._v("[ ] HTTP的缓存技术简单讲一下")])]),_._v(" "),v("li",[v("p",[_._v("[ ] HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0特点")])]),_._v(" "),v("li",[v("p",[_._v("[ ] HTTPS 和 HTTP")])]),_._v(" "),v("li",[v("p",[_._v("[ ] HTTPS是如何进行连接的（不熟悉）")])]),_._v(" "),v("li",[v("p",[_._v("get 和 post 请求的区别")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("get 请求的参数数据一般都是在 url 中展示的，post 请求的数据一般是以 json（任意形式） 形式通过TCP协议进行发送过去的；")])]),_._v(" "),v("li",[v("p",[_._v("安全 和 幂等：在 HTTP 协议中，所谓安全的方法就是不会破坏掉服务器上的资源；幂等就是 多次执行相同的操作，返回的结果是相同的。")]),_._v(" "),v("p",[_._v("从这方面说，get请求是从服务器中获取资源，并不会改变服务器的资源，那么可以说是安全 且 幂等的；")]),_._v(" "),v("p",[_._v("但是post请求的话，他是会改变服务器的资源的，每次post之后都会创建新的资源，所以post不是幂等也不是安全的；（但这只是一般的情况下）")])]),_._v(" "),v("li",[v("p",[_._v("可缓存与不可缓存：")])])])]),_._v(" "),v("li",[v("p",[_._v("HTTPS 解决了 HTTP 的啥问题，怎么解决的？")]),_._v(" "),v("p",[v("em",[v("strong",[_._v("混合加密")])]),_._v(" 解决了HTTP中信息被被窃听的危险；")]),_._v(" "),v("p",[v("em",[v("strong",[_._v("摘要算法 + 数字签名")])]),_._v(" 解决了HTTP中信息被篡改的危险；")]),_._v(" "),v("p",[v("em",[v("strong",[_._v("数字证书")])]),_._v(" 解决了HTTP中信息被冒充的危险。")]),_._v(" "),v("p",[_._v("混合加密：通信前，使用的是非对称加密手段（两把密钥进行操作）；通信后，使用对称加密的手段进行信息传输")]),_._v(" "),v("p",[_._v("我们担心传输的信息被篡改被冒充，但是这些都不是事；"),v("strong",[_._v("【私钥加密，公钥解密】")]),_._v(" 这是一个可以防止信息被冒充的一个办法，因为私钥是独有的不可泄漏的，公钥是给每个人进行颁发的，如果我这个利用公钥能解开你的私钥，那么这个信息就只能是你的了，解决了冒充信息的缺点。")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png",alt:"img"}})]),_._v(" "),v("p",[v("strong",[_._v("私钥是服务端进行保管的")]),_._v("，然后"),v("strong",[_._v("服务端向客户端颁发对应的公钥")]),_._v("。客户端收到的消息如果可以被公钥进行解密，那么就说明这个消息是由服务器发送的。")]),_._v(" "),v("p",[_._v("但是问题来了，这个颁发后的公钥有可能是伪造的呀~那样的话还是会出现信息篡改的问题。")]),_._v(" "),v("p",[_._v("服务器先将自己的公钥去到CA进行申请数字证书，CA用自己的私钥将 服务器发来的 公钥 + 数字证书进行加密，然后CA自己的公钥是存储在浏览器或者是OS中的。客户端是会拿到这个CA的公钥，然后对数字证书进行解密，获得 服务器的公钥 + 数字签名，然后对信息进行信息加密后传输，然后服务器再根据自己的私钥进行解密的。以上这个流程，通过 数字证书的方式来保证了服务器公钥的身份，避免了被冒充的风险。")])]),_._v(" "),v("li",[v("p",[_._v("HTTPS是如何建立连接的，期间的交互是如何的？")]),_._v(" "),v("p",[_._v("HTTPS建立连接，相对于HTTP连接，就是多了一层 TLS/SSL这个基本的连接（这里只需要讲"),v("strong",[_._v("基于EDCHE算法实现")]),_._v("的即可）")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("客户端发送【clienthello】，其中包含的信息为 TLS 版本；随机数；密码套件；")])]),_._v(" "),v("li",[v("p",[_._v("服务端发送【server hello 】消息 确认客户端发来的TLS版本，然后自己也生成一个随机数，然后根据密码套件列表中选择一个合适的密码套件；为了证明自己的身份，还会发送【certificate】将 数字证书 发送给客户端；随后还会发送【Server Key Exchange】消息给客户端，这个过程干了三件事：")]),_._v(" "),v("ul",[v("li",[_._v("选择一个椭圆曲线，相当于在选好了一个椭圆曲线的基点G，会公开给客户端；")]),_._v(" "),v("li",[_._v("生成一个随机数作为服务端的私钥，保留在本地；")]),_._v(" "),v("li",[_._v("根据基点G和私钥计算出 服务端的椭圆曲线的公钥（这个公钥会进行RSA算法进行数字签名 存储在 数字证书上），公开给客户端；")])]),_._v(" "),v("p",[_._v("随后就发送【server hello down】消息，服务端给客户端表明：我消息已发完；")])]),_._v(" "),v("li",[v("p",[_._v("客户端会根据在浏览器或者OS的CA公钥来进行对服务端发来的数字证书进行校验，会得到服务器的公钥，无误后往下走；")]),_._v(" "),v("p",[_._v("客户端也会自己生成一个随机数作为自己椭圆曲线的私钥，然后并且根据服务端前面发来的消息生成客户端的公钥，然后用【client Key Exchange】消息发送给服务端；")]),_._v(" "),v("p",[_._v("此时 就可以算出 x 的密钥条件之一：利用自己椭圆曲线的私钥 + 对方椭圆曲线的公钥 + 椭圆曲线基点G算出；")]),_._v(" "),v("p",[_._v("真正的会话密钥：客户端随机数 + 服务端随机数 + x；")]),_._v(" "),v("p",[_._v("然后客户端最后再发送这个【Change Cipher Spec】消息告诉服务端后续改用这个对称算法加密通信（并且 这里可以携带真正的数据过去的）；客户端还需要发送一个消息过去【Encrypted handshake Message】，将之前的消息做一个摘要然后加密发送过去给服务端验证本次的密钥是否正常使用；")])]),_._v(" "),v("li",[v("p",[_._v("服务端也会回应一个【Change Cipher Exchange】和【Encrypted handshake Message】也做一个改变通信方式以及验证加密是否可用，就建立完连接了；")])])])]),_._v(" "),v("li",[v("p",[_._v("301 和 302、304 状态码的区别")]),_._v(" "),v("p",[_._v("301 表示永久重定向；需要用新的URL才能进行访问；")]),_._v(" "),v("p",[_._v("302 表示临时重定向；需要暂时用另一个URL才能进行访问；")]),_._v(" "),v("p",[_._v("304 不具有跳转的含义，表示"),v("strong",[_._v("资源未修改")]),_._v("，重定向已经存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用本地磁盘缓存的资源。")])]),_._v(" "),v("li",[v("p",[_._v("强制缓存 以及 协商缓存")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("强制缓存：只要浏览器判断缓存没有过期，直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边；")])]),_._v(" "),v("li",[v("p",[_._v("协商缓存：客户端与服务端协商之后，通过协商结果来判断是否使用本地缓存；")]),_._v(" "),v("p",[_._v("过程如下：")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png",alt:"img"}})])])])]),_._v(" "),v("li",[v("p",[_._v("HTTP 1.1、HTTP 2.0、HTTP3.0都有啥特点")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("HTTP 1.1 相对于 HHTP1.0 来说，改变了两点：第一、变成长连接了；第二、变成管道运输，支持多个请求发送，不需要等到响应回来再去发送；")])]),_._v(" "),v("li",[v("p",[_._v("HTTP 2.0 是基于 HTTPS的；")]),_._v(" "),v("p",[_._v("第一个特点：头部压缩，减少这个空间；"),v("code",[_._v("HPACK")]),_._v(" 算法：在服务端和客户端同时"),v("strong",[_._v("维护了一张头信息表")]),_._v("，所有字段都会存入这个表中，同时发送多个请求，请求头是一样的话，协议会自动消除重复的部分；")]),_._v(" "),v("p",[_._v("第二个特点：由以前的文本传输，变成二进制传输，空间减少；头信息的报文变成 "),v("strong",[_._v("头信息帧")]),_._v("；数据体变成"),v("strong",[_._v("数据帧")])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://camo.githubusercontent.com/1c35c3b57d9e16e9a44a4a63b83971a1e2f85344b94d45a2b42ed8b3ea3a00c0/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470322f2545342542412538432545382542462539422545352538382542362545352542382541372e706e67",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("第三个特点：支持并发传输；一个 TCP 链上有多个 Stream，而一个Stream上有多个Message，所谓的 Message 就是我们的请求-响应模型，一个Message上有多个frame，我们的frame就是我们的消息，即数据帧（头部和包体），可以乱序发送的，接受的时候会自己进行组装信息；（但是很遗憾没有办法解决这个"),v("strong",[_._v("TCP层面队头阻塞")]),_._v("问题：因为多个Stream在一条TCP链上的，只要有一个数据帧丢失了，这个TCP链都需要被阻塞，直到这个丢失的数据帧重新发回）")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示 "),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("第四个特点：服务器可以主动推送消息给客户端；当客户端发送一次请求过去给服务端的时候，服务端可以一次性将html 以及 css 页面返回；")])]),_._v(" "),v("li",[v("p",[_._v("HTTP3.0 是基于UDP的QUIC协议进行传输的，可以完美解决这个队头阻塞问题；")]),_._v(" "),v("p",[_._v("第一个特点：HTTP3.0 是无队头阻塞的，当某个流发生丢包问题的时候，只会阻塞这个流，并不会阻塞其他流，因此存在这个队头阻塞的问题；为什么可以这样？QUIC也是借鉴了HTTP2.0的一个QUIC链上多个Stream流，但是QUIC协议给每个stream流安排了一个单独的滑动窗口；")]),_._v(" "),v("p",[_._v("第二个特点：更快的连接建立，我们知道HTTP2是基于HTTPS的，需要经过SSL的四次握手以及TCP的三次握手，耗时 3-RTT 时延；但是HTTP3.0的基于UDP的QUIC协议是很快的，其封装了SSL1.3+版本的，只需要一个RTT时间即可；")]),_._v(" "),v("p",[_._v("第三个特点：连接迁移更快，我们知道TCP是根据目标IP，目标端口号，主机IP，主机端口号进行连接的；所以每一次的切换网络的时候都是比较耗性能的，但是这只需要双方建立连接 ID 即可进行重连。")])])])])]),_._v(" "),v("h2",{attrs:{id:"osi五层模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#osi五层模型"}},[_._v("#")]),_._v(" OSI五层模型")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("[ ] 五层模型的名称，主要协议，以及每层的作用")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片"),v("OutboundLink")],1)])])]),_._v(" "),v("p",[_._v("应用层：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("主要的协议：HTTP、FTP、DNS")]),_._v(" "),v("p",[_._v("这个层主要是用户能真正接触到一个层，"),v("strong",[_._v("专注于给用户提供应用功能")]),_._v("；该层位于用户态；其余的都是在内核态")])])]),_._v(" "),v("p",[_._v("传输层：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("TCP、UDP")]),_._v(" "),v("p",[_._v("该层负责对数据进行传输；当数据从HTTP传来时，对数据进行组装；该层传输的数据包含了端口号；")])])]),_._v(" "),v("p",[_._v("网络层：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("IP")]),_._v(" "),v("p",[_._v("该层负责的是网络的连接，将数据从一个设备传输到另一个设备；其中网络连接需要知道网络号和主机号，如何求得这两个号就需要IP的数值和子网掩码进行按位运算取得的；")]),_._v(" "),v("p",[_._v("还有一个功能就是路由：通过路由算法来找到下一个路径在哪，路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络；")])])]),_._v(" "),v("p",[_._v("网络接口层：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("MAC")]),_._v(" "),v("p",[_._v("该层协议主要是将数据封装成帧进行传输了；利用ARP协议获取对方的MAC地址即可；")])])]),_._v(" "),v("h2",{attrs:{id:"tcp-udp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-udp"}},[_._v("#")]),_._v(" TCP UDP")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("[ ] TCP UDP 的区别（七个）、应用场景")])]),_._v(" "),v("li",[v("p",[_._v("[ ] 三次握手、四次挥手，为什么是三次不是两次；为什么是四次能不能是三次，以及每个过程的状态码是否能说出来")])]),_._v(" "),v("li",[v("p",[_._v("[ ] time wait 的作用以及 为什么是 2MSL")])]),_._v(" "),v("li",[v("p",[_._v("[ ] TCP的 超时重传、滑动窗口、流量控制、拥塞控制（不熟悉）")])]),_._v(" "),v("li",[v("p",[_._v("[ ] 基于 UDP 的 QUIC 协议简单说说")])]),_._v(" "),v("li",[v("p",[_._v("[ ] 紧急指针的作用")])]),_._v(" "),v("li",[v("p",[_._v("[ ] TCP HTTP的粘包拆包问题，有哪些方案可以解决")])]),_._v(" "),v("li",[v("p",[_._v("如何解决粘包拆包问题？")]),_._v(" "),v("ul",[v("li",[_._v("TCP是基于流的传输，没有明显的界定条件；")]),_._v(" "),v("li",[_._v("应用程序读取的速度不匹配：当接收方读取数据的速度和发送方发送数据的速度不一致的时候，无法判断数据包的边界也会导致粘包问题；")]),_._v(" "),v("li",[_._v("发送方将数据写入缓冲区的时候是等到数据量较大的时候才进行发送的，所以导致多个小数据包被合并导致粘包拆包问题；")])]),_._v(" "),v("p",[_._v("TCP中有三个方案：")]),_._v(" "),v("ul",[v("li",[_._v("固定的数组进行装载，但是缺点也很明显：就是如果数据量很小的时候就会导致空间浪费；")]),_._v(" "),v("li",[_._v("使用特殊的符号，比如HTTP使用空格进行分割，或者可以用 “\\r\\n”；")]),_._v(" "),v("li",[_._v("使用头部 + 数据包的方式：头部有一个固定的字段指定了后面数据包的大小；")])]),_._v(" "),v("p",[_._v("HTTP中如何解决的？")]),_._v(" "),v("p",[_._v("HTTP不会出现粘包半包问题，在长持久的连接中可能会出现多个信息混在一起的情况，HTTP1.1中是利用了空行，每个消息之间都有一个空行来进行分割的；HTTP2.0中是利用了帧头信息进行分割，其中帧头就是我们第三种方案嘛")])]),_._v(" "),v("li",[v("p",[_._v("紧急指针")]),_._v(" "),v("p",[_._v("TCP是面向数据流的协议，当应用程序发生紧急情况（比如说被中断连接的时候），要求在接收方没有处理完数据之前就能够发送一些紧急数据，然后发送方会将urg字段标为1，表示为紧急指针有效，这样就不需要考虑你数据在数据流的位置，直接升级为优先级最高。")])]),_._v(" "),v("li",[v("p",[_._v("流量控制")]),_._v(" "),v("p",[_._v("TCP提供的一种让【发送方】根据【接收方】的实际接收能力来控制数据的传输；")])]),_._v(" "),v("li",[v("p",[_._v("滑动窗口")]),_._v(" "),v("p",[_._v("窗口的大小是 不需要进行响应，而可以继续发送的最大数据量；")]),_._v(" "),v("p",[_._v("滑动窗口是【接收方】告诉【发送方】自己的实际接受能力，不至于发送方发送过多的数据让接收方没办法处理。")])]),_._v(" "),v("li",[v("p",[_._v("拥塞机制")]),_._v(" "),v("ul",[v("li",[_._v("几个比较重要的名词：慢启动，慢启动门阀，拥塞窗口、轮次")]),_._v(" "),v("li",[_._v("四个算法：慢启动（指数相加）、拥塞避免（线性相加）、拥塞发生、快速恢复")])])])]),_._v(" "),v("h2",{attrs:{id:"其他"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[_._v("#")]),_._v(" 其他")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("[ ] 输入一个 url ，会发生啥？（不熟悉）")]),_._v(" "),v("p",[_._v("涉及到三个进程：浏览器进程、网络进程、服务器")]),_._v(" "),v("p",[_._v("浏览器负责检查和组装我们的协议，构成完整的 url；然后浏览器通过"),v("strong",[_._v("进程间的通信")]),_._v("将我们的 url 请求交给我们的网络进程；")]),_._v(" "),v("p",[_._v("网络进程收到我们的 url 后进行检查本地缓存是否缓存了该请求内容，如果有则返回，没有则向 web 服务器发送 HTTP 请求，请求流程如下：")]),_._v(" "),v("ul",[v("li",[_._v("如果是域名的话就进行 DNS 解析，获取我们的 IP 地址和端口号；")]),_._v(" "),v("li",[_._v("利用 ip 和 端口号和服务器进行 tcp 连接")]),_._v(" "),v("li",[_._v("构建请求头并且发送")]),_._v(" "),v("li",[_._v("服务器响应后，网络进程接收请求头和响应信息，并且解析响应内容")])]),_._v(" "),v("p",[_._v("网络进程解析响应内容流程：")]),_._v(" "),v("ul",[v("li",[_._v("如果状态码是 301（永久重定向） 302（临时重定向），就需要重定向；如果是 304 就缓存重定向即可")]),_._v(" "),v("li",[_._v("如果是 200 就代表响应内容获取成功，如果是字节流就使用下载管理器进行处理，如果是 html 类型的就进行渲染（渲染进程处理）操作即可")])])]),_._v(" "),v("li",[v("p",[_._v("[ ] 计算机网络用来做什么？")])]),_._v(" "),v("li",[v("p",[_._v("[ ] 协议到底是什么？")])]),_._v(" "),v("li",[v("p",[_._v("[ ] 网关是什么？正向反向代理是什么？（不熟悉）")])]),_._v(" "),v("li",[v("p",[_._v("[ ] ARP协议的如何工作？（不熟悉）")])]),_._v(" "),v("li",[v("p",[_._v("[ ] DNS如何工作？")])]),_._v(" "),v("li",[v("p",[_._v("[ ] cookie session token 是啥，作用是啥")])]),_._v(" "),v("li",[v("p",[_._v("cookie session token 是啥，作用是啥")]),_._v(" "),v("ul",[v("li",[_._v("cookie一般是用来存储用户相对不那么重要的信息的，因为http是无状态连接嘛 哈哈 ；服务器产生的，存储在客户端；")]),_._v(" "),v("li",[_._v("session 一般是用来存储用户的认证那些比较重要的消息的，服务端产生，存储在客户端；")]),_._v(" "),v("li",[_._v("因为我们的app 公众号 小程序没有浏览器嘛，就需要token，用来做身份鉴权的，限制某些资源的访问，服务端产生，服务端存储；")])])])]),_._v(" "),v("p",[_._v("补充一下：cookie 是保存在客户端的一小块文本串的数据，可以根据这个 cookie 判断用户的身份和状态； "),v("strong",[_._v("session 指的就是服务端和客户端一次会话的过程")]),_._v(" ，用于记录客户状态的机制；")]),_._v(" "),v("p",[_._v("作用：")]),_._v(" "),v("ul",[v("li",[_._v("存储时间来看：cookie 长期可以，但是 session 是短期的；")]),_._v(" "),v("li",[_._v("存储大小不同：cookie 不超过 4k，但是 session 存储的数据远远大于 cookie的；")]),_._v(" "),v("li",[_._v("还可以利用 cookie 记录 session 的标识，第一次访问服务器的时候会创建一个 session 进行存储在我们的服务器中，并且返回 sessionId 给我们的 客户端中的 cookie 进行存储，第二次进行访问的时候会根据这个 sessionId 来判断我们的登录是否登录或者是登录失效，如果找到 Session 证明用户已经登录可以执行后面的操作了；")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6110cb0871614cab860e891e192a33b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",alt:"Session和Cookie的关联"}})]),_._v(" "),v("p",[v("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6110cb0871614cab860e891e192a33b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("同时如果是在分布式场景如何解决 Session 问题？")]),_._v(" "),v("p",[_._v("可以利用分布式缓存 Redis 进行存储，然后在多台服务器之间进行共享。")]),_._v(" "),v("h2",{attrs:{id:"补充一下经常会忘记的知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充一下经常会忘记的知识"}},[_._v("#")]),_._v(" 补充一下经常会忘记的知识")]),_._v(" "),v("h3",{attrs:{id:"http-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[_._v("#")]),_._v(" HTTP")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("[ ] HTTP 和 HTTPS 的区别？")]),_._v(" "),v("p",[_._v("端口号：80 443")]),_._v(" "),v("p",[_._v("保密性：S 多了个 SSL/TLS 中间层")]),_._v(" "),v("p",[_._v("HTTPS 通过向 CA 申请数字证书解决了 HTTP 的被冒充的可能，同时也避免了被篡改的可能")]),_._v(" "),v("p",[_._v("这里可以说如何解决这个被冒充的；如何解决信息不被篡改的等。")])]),_._v(" "),v("li",[v("p",[_._v("[ ] HTTPS 的连接过程？")]),_._v(" "),v("p",[_._v("四次握手：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("第一次握手：")]),_._v(" "),v("p",[_._v("客户端：客户端发送请求连接给服务端，请求的端口为 443；与此同此还会发送客户端随机生成的随机数以及SSL版本号以及密码套件给服务端；")])]),_._v(" "),v("li",[v("p",[_._v("第二次握手：")])])]),_._v(" "),v("p",[_._v("服务端：服务端接收到客户端的请求后，检查这个 SSL 的版本号确定没问题了，就发送 "),v("strong",[_._v("CA颁发的数字证书")]),_._v(" 给客户端，其中这个证书包含着公钥（这个公钥是利用 "),v("strong",[_._v("服务端自己生成的私钥 + 椭圆曲线的G点")]),_._v(" （是基于 ECDHE 这个算法不是 RSA 这个算法）生成的）以及证书的失效时间等信息；")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("第三次握手：")]),_._v(" "),v("p",[_._v("客户端：客户端利用 "),v("strong",[_._v("浏览器缓存的 CA公钥 验证这个数字证书")]),_._v("，没问题之后，"),v("strong",[_._v("获取到服务端的公钥")]),_._v("，同时"),v("strong",[_._v("客户端自己也会生成一个随机数来作为椭圆曲线的私钥")]),_._v("，所以就生成一个随机码数（自己的私钥 + 对方的公钥 + 椭圆曲线G + 客户端的随机数 + 服务端的随机数）作为会话密钥，并且使用 "),v("strong",[_._v("服务端的公钥进行加密")]),_._v("，然后传送给服务端；")])]),_._v(" "),v("li",[v("p",[_._v("第四次握手")]),_._v(" "),v("p",[_._v("服务端：服务端利用这个 先前保留的 "),v("strong",[_._v("自己的私钥进行解密")]),_._v("，获取到了随机码后，使用随机码进行加密信息，客户端收到信息后也会使用这个随机码解密信息，从此加密通信形成了。")])])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0c5c0530bf04b51be1642d3819306d1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片"),v("OutboundLink")],1)])]),_._v(" "),v("li",[v("p",[_._v("[ ] 客户端如何校验 CA证书 的合法性？")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("CA签发证书的过程：")]),_._v(" "),v("p",[_._v("CA 机构会将持有者的公钥、用途、有效信息等打成一个包，然后对这些信息进行 Hash 运算；")]),_._v(" "),v("p",[_._v("然后 CA 机构利用这个"),v("strong",[_._v("私钥")]),_._v("对这个 Hash 值进行一个加密处理，生成一个证书签名，也就是 CA 对证书做了一个数字签名；")]),_._v(" "),v("p",[_._v("最后将这个"),v("strong",[_._v("数字签名添加在文件证书")]),_._v("上，形成"),v("strong",[_._v("数字证书")]),_._v("；")])]),_._v(" "),v("li",[v("p",[_._v("客户端校验服务端的数字证书的过程")]),_._v(" "),v("p",[_._v("客户端会利用同样的 Hash 函数进行获取到我们的 Hash 值 H1；")]),_._v(" "),v("p",[_._v("然后客户端利用 浏览器中的 CA的公钥信息进行解密证书中的数字签名，获取到我们的 Hash 值 H2；")]),_._v(" "),v("p",[_._v("最后比较 H1 和 H2，如果值相同，则为可信赖的证书。")])])]),_._v(" "),v("p",[_._v("假如中间有人篡改了证书的内容，他又没有 CA 的私钥，所以说，客户端用公钥进行解密的内容就不一致了。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f9edfe0e5f646f1a725c1f3601143da~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",alt:"证书签名和客户端校验-来源参考[2]"}})])])]),_._v(" "),v("p",[_._v("​\t\t"),v("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f9edfe0e5f646f1a725c1f3601143da~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片"),v("OutboundLink")],1)]),_._v(" "),v("ul",[v("li",[v("p",[_._v("[ ] 对称加密和非对称加密说一下？")]),_._v(" "),v("p",[_._v("参考上面的 HTTPS 的连接过程")]),_._v(" "),v("p",[_._v("第二次握手和第三次握手都是使用 非对称加密，第四次握手是真正传消息的时候就是用 对称加密了；")]),_._v(" "),v("p",[v("strong",[_._v("公钥加密，私钥解密")]),_._v("：保证了这个信息的安全性，"),v("strong",[_._v("因为私钥是独有的，只有有私钥的人才会获取到我们信息")]),_._v("；")]),_._v(" "),v("p",[v("strong",[_._v("私钥加密，公钥解密")]),_._v("：保证了这个身份不被冒充，"),v("strong",[_._v("因为私钥不会被泄露的")]),_._v("，持有公钥的人能解开信息证明信息确实是来自于持有私钥的人。")])]),_._v(" "),v("li",[v("p",[_._v("[ ] CA 证书的作用？")]),_._v(" "),v("p",[_._v("参考上面")])]),_._v(" "),v("li",[v("p",[_._v("[ ] 加密算法具体有哪些？")]),_._v(" "),v("p",[_._v("MD5：用于数据完整性的校验；")]),_._v(" "),v("p",[_._v("RSA：常用于加密和数字签名；或者说是交换密钥算法")]),_._v(" "),v("p",[_._v("ECDHE：常用于加密和数字签名；或者说是交换密钥算法")])])]),_._v(" "),v("h3",{attrs:{id:"tcp-udp-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-udp-2"}},[_._v("#")]),_._v(" TCP UDP")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("[ ] TCP三次握手四次挥手状态码")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP 三次握手"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png",alt:"TCP 三次握手"}})]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("TCP 四次挥手"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png",alt:"客户端主动关闭连接 —— TCP 四次挥手"}})])]),_._v(" "),v("li",[v("p",[_._v("[ ] 为什么需要 2msl？")]),_._v(" "),v("p",[_._v("这个问题知道之前，首先要知道为什么要 TIME_WAIT 阶段？")]),_._v(" "),v("p",[_._v("只有主动关闭连接的一方，才有这个 TIME_WAIT 阶段；")]),_._v(" "),v("ol",[v("li",[_._v("防止历史连接中，被后面相同的"),v("a",{attrs:{href:"https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230433082.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("四元组"),v("OutboundLink")],1),_._v("的连接错误的接收；")]),_._v(" "),v("li",[_._v("保证【被动关闭连接】的一方，能被正确地关闭；TIME-WAIT 作用是"),v("strong",[_._v("等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。")])])]),_._v(" "),v("p",[_._v("好了，了解了为什么需要 TIME_WAIT 之后，我们来看看为什么需要 2msl，就是：")]),_._v(" "),v("p",[v("strong",[_._v("我们允许报文丢失一次")]),_._v("；如果被动关闭方没有接收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，就会重发 ACK 给被动关闭方，一来一去正好 2 个 msl，而且我们需要知道，"),v("strong",[_._v("2MSL 的时间是从客户端收到 FIN 后发送 ACK 开始计时的；")])])]),_._v(" "),v("li",[v("p",[_._v("[ ] TCP保证可靠性的手段？（超时重传 --- 滑动窗口 --- 流量控制 --- 拥塞控制）")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d64c59c6f4ea48f28dd5a31677c031e7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)])]),_._v(" "),v("li",[v("p",[_._v("[ ] 粘包和半包问题如何产生？又如何解决？")]),_._v(" "),v("ul",[v("li",[_._v("TCP是基于流的传输，没有明显的界定条件；")]),_._v(" "),v("li",[_._v("应用程序读取的速度不匹配：当接收方读取数据的速度和发送方发送数据的速度不一致的时候，无法判断数据包的边界也会导致粘包问题；")]),_._v(" "),v("li",[_._v("发送方将数据写入缓冲区的时候是等到数据量较大的时候才进行发送的，所以导致多个小数据包被合并导致粘包拆包问题；")])]),_._v(" "),v("p",[_._v("TCP中有三个方案：")]),_._v(" "),v("ul",[v("li",[_._v("固定的数组进行装载，但是缺点也很明显：就是如果数据量很小的时候就会导致空间浪费；")]),_._v(" "),v("li",[_._v("使用特殊的符号，比如HTTP使用空格进行分割，或者可以用 “\\r\\n”；")]),_._v(" "),v("li",[_._v("使用头部 + 数据包的方式：头部有一个固定的字段指定了后面数据包的大小；")])]),_._v(" "),v("p",[_._v("HTTP中如何解决的？")]),_._v(" "),v("p",[_._v("HTTP不会出现粘包半包问题，在长持久的连接中可能会出现多个信息混在一起的情况，HTTP1.1中是利用了空行，每个消息之间都有一个空行来进行分割的；HTTP2.0中是利用了帧头信息进行分割，其中帧头就是我们第三种方案嘛")])])]),_._v(" "),v("h2",{attrs:{id:"ip"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ip"}},[_._v("#")]),_._v(" IP")]),_._v(" "),v("p",[_._v("这里写一些 IP 层的基础知识；")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("什么是 IP 地址？作用是啥？")]),_._v(" "),v("p",[_._v("IP 地址分为 IPV4 和 IPV6，IPV4的表示的方式是通过【.】来进行分割的，每一个代表十进制；共 32 位，其中分为 4 组，每组 8 位；IPV6的表示的方式是通过【:】进行分割，共 128 位，每 16 位为一组；")]),_._v(" "),v("p",[_._v("这里又会延申一个重要的问题：IPV4 和 IPV6 有哪些区别？")]),_._v(" "),v("p",[_._v("除了上面的标识不一样外，还有 IPV6 能给每个计算机都分配一个公有的 IP 地址，这样的话就不需要 NAT 技术了；同时还去掉了包头校验和，简化首部结构，减轻了路由器负荷，大大提升了传输性能；")]),_._v(" "),v("p",[v("strong",[_._v("作用就是 将数据包从一个主机经过网络上传送到另一个主机；")])])]),_._v(" "),v("li",[v("p",[_._v("IP 层和 MAC 层的区别")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/3.jpg",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/3.jpg",alt:"IP 的作用与 MAC 的作用"}})]),_._v(" "),v("p",[v("strong",[_._v("源 IP 地址和目标 IP 地址在传输过程中是不会发生变化的（前提是没有使用 NAT）；而源 MAC 地址和目标 MAC 地址是一直发生变化的。")])])]),_._v(" "),v("li",[v("p",[_._v("无分类地址 CIDR")]),_._v(" "),v("p",[_._v("32 比特的 IP 地址被分为两部分，"),v("strong",[_._v("网络号")]),_._v("和"),v("strong",[_._v("主机号")]),_._v("；")]),_._v(" "),v("p",[_._v("比如说：10.100.122.2/24 代表着 "),v("strong",[_._v("前24位网络号")]),_._v("，"),v("strong",[_._v("后8位位主机号")])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/15.jpg",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/15.jpg",alt:"img"}})]),_._v(" "),v("p",[_._v("这里的网络号又是如何获取的呢？这里需要提到子网掩码，这也是一种划分网络号和主机号的方式（掩码的意思是遮住主机号，剩余的就是网络号了）；")]),_._v(" "),v("p",[v("strong",[_._v("将子网掩码和 IP 地址进行按位计算 AND，则可得到网络号")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg",alt:"img"}})]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)])]),_._v(" "),v("li",[v("p",[_._v("路由器寻址的过程")]),_._v(" "),v("p",[_._v("当路由器接收到 IP 地址的时候，就需要判断两个主机是否处于一个广播域内，即是否有同样的网络号，网络号相同，表示接收方在本网络上，可以直接将数据包进行传送过去；")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)])]),_._v(" "),v("li",[v("p",[_._v("公有 IP 地址和私有 IP 地址")]),_._v(" "),v("p",[_._v("可以类比与你家住1栋 502，我家也是 1栋502，但是出了外面，就需要加上具体的地址名字了；xx路xx街道xx小区1栋502这样才行；")]),_._v(" "),v("p",[v("strong",[_._v("公有 IP 地址是唯一的；私有 IP 地址可以不唯一")])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/23.jpg",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/23.jpg",alt:"公有 IP 地址与私有 IP 地址"}})])]),_._v(" "),v("li",[v("p",[_._v("IP 分片和重组")]),_._v(" "),v("p",[_._v("IP 数据包大于 MTU 时，IP 数据包会被分片，经分片之后的 IP 数据在进行重组的时候，"),v("strong",[_._v("只能由目标主机进行，路由器是不会进行重组的")]),_._v("；")]),_._v(" "),v("p",[_._v("在分片传输过程中，一旦某个分片丢失了，会造成整个 IP 数据报作废，所以 TCP 引入了 MSS 也就是在 TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 MTU 的数据报文；")])]),_._v(" "),v("li",[v("p",[_._v("我们知道 IPV4 不够用了，但是 IPV6 又不能一下子替换了我们的 IPV4，中间用什么手段来缓解呢？")]),_._v(" "),v("p",[_._v("用 NAT，什么是 NAT呢？简单来说，同个公司、家庭、教室内的主机对外通信时，"),v("strong",[_._v("把私有的 IP 地址转换成公有的 IP 地址；")])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/38.jpg",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/38.jpg",alt:"NAT"}})]),_._v(" "),v("p",[_._v("但是普通的 NAT 的技术不行，需要用到一个"),v("strong",[_._v("网络地址与端口转换 NAPT")]),_._v(" 技术才行；图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进行通信，并且客户端本地端口都是 1025；")]),_._v(" "),v("p",[_._v("此时，"),v("strong",[_._v("两个私 IP 地址都转换为公有地址 120.229.175.121 ，但是以不同的端口号作为区分。")])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/39.jpg",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/39.jpg",alt:"NAPT"}})])])])])}),[],!1,null,null,null);v.default=o.exports}}]);