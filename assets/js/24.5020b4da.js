(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{413:function(_,v,o){"use strict";o.r(v);var e=o(2),c=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("以下内容参考 "),v("a",{attrs:{href:"https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-dma-%E6%8A%80%E6%9C%AF",target:"_blank",rel:"noopener noreferrer"}},[_._v("小林coding"),v("OutboundLink")],1),_._v(" 并做总结")]),_._v(" "),v("h2",{attrs:{id:"什么是-dma-技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-dma-技术"}},[_._v("#")]),_._v(" 什么是 DMA 技术？")]),_._v(" "),v("p",[_._v("因为我们的零拷贝技术是基于这个 "),v("code",[_._v("DMA")]),_._v(" 技术的，所以我们需要知道什么是 "),v("code",[_._v("DMA")]),_._v(" 技术，所谓的 "),v("code",[_._v("DMA")]),_._v(" 技术就是内存直接访问技术，简单来说，"),v("strong",[_._v("在我们进行IO设备和内存的数据传输的时候，数据搬运工作不需要 CPU 来执行，而是交给我们的 DMA 控制器来执行，而 CPU 就不需要参与任何数据搬运的事情，只需要负责发指令（传输什么数据，从哪里传输到哪里等）即可，这样 CPU 就能执行其他的事务了。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/DRM%20I_O%20%E8%BF%87%E7%A8%8B.png",alt:"img"}})]),_._v(" "),v("h2",{attrs:{id:"传统传输文件的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传统传输文件的过程"}},[_._v("#")]),_._v(" 传统传输文件的过程")]),_._v(" "),v("p",[_._v("举个例子：我们进行一次读写文件；")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png",alt:"img"}})]),_._v(" "),v("p",[_._v("可以看出发生了"),v("strong",[_._v("四次的用户态到内核态的上下文切换")]),_._v("，因为发生了 "),v("code",[_._v("read()")]),_._v(" 和 "),v("code",[_._v("write()")]),_._v(" 嘛，每次"),v("strong",[_._v("系统调用都需要从用户态切换到内核态，等内核完成之后再从内核态转换为用户态")]),_._v("。")]),_._v(" "),v("p",[_._v("期间还发生了"),v("strong",[_._v("四次数据的拷贝")]),_._v("，其中两次是（磁盘控制器 ---\x3e 内核缓冲区 ||  "),v("code",[_._v("socket")]),_._v("缓冲区 ---\x3e 网卡缓冲区） "),v("code",[_._v("DMA")]),_._v(" 拷贝，两次是（内核缓冲区 ---\x3e 用户缓冲区 || 用户缓冲区  ---\x3e  "),v("code",[_._v("socket")]),_._v(" 缓冲区）内核缓冲区即 "),v("code",[_._v("CPU")]),_._v("拷贝；")]),_._v(" "),v("p",[_._v("本想着搬运一次的数据，却需要搬运四次，所以说，必须要减少这个上下文切换的次数以及这个数据拷贝的次数。")]),_._v(" "),v("p",[_._v("我们可以从图中看到，从 【内核缓冲区 拷贝到 用户缓冲区】以及【用户缓冲区 拷贝到 "),v("code",[_._v("socket")]),_._v(" 缓冲区】这个过程是没必要的，因为传输数据过程中不会对数据进行加工。")]),_._v(" "),v("h2",{attrs:{id:"实现零拷贝技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现零拷贝技术"}},[_._v("#")]),_._v(" 实现零拷贝技术")]),_._v(" "),v("ol",[v("li",[_._v("mmap + write（了解）")]),_._v(" "),v("li",[_._v("sendfile")])]),_._v(" "),v("p",[_._v("这里重点讲一下这个 "),v("code",[_._v("sendfile")]),_._v(" 技术，我们现在的 "),v("code",[_._v("linux")]),_._v(" 也支持这个 "),v("code",[_._v("SG-DMA")]),_._v(" 技术（这一步可以减少 内核缓冲区 ---\x3e "),v("code",[_._v("socket")]),_._v(" 缓冲区 这个过程，"),v("strong",[_._v("直接从内核缓冲区 ---\x3e 网卡缓冲区")]),_._v("）；内核缓冲区只需要将 这个描述符和数据长度 发送给 "),v("code",[_._v("socket")]),_._v(" 缓冲区")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png",alt:"img"}})]),_._v(" "),v("p",[_._v("这就是所谓的"),v("strong",[_._v("零拷贝技术")]),_._v("了，"),v("strong",[_._v("我们没有在内存层面去拷贝技术，也就是说全程没有通过这个 "),v("code",[_._v("CPU")]),_._v(" 来搬运数据，全部都是由这个 "),v("code",[_._v("DMA")]),_._v(" 技术来进行搬运的")]),_._v("。传统的文件传输需要四次的上下文切换以及四次的数据拷贝，而我们的零拷贝只需要两次的上下文切换以及两次的数据拷贝即可，而且我们的数据拷贝都不需要 "),v("code",[_._v("CPU")]),_._v(" 来参与，都是我们的 "),v("code",[_._v("DMA")]),_._v(" 控制器来进行参与的；")]),_._v(" "),v("p",[_._v("我们提到的内核缓冲区是啥？")]),_._v(" "),v("p",[_._v("其实就是 "),v("code",[_._v("pageCache")]),_._v("，两个主要的特点：第一个是 可以缓存最近被访问的数据（局部性原理）；第二点是有这个预读的功能，当 "),v("code",[_._v("read()")]),_._v(" 的时候虽然只是读到了 0- 32 字节的数据，但是可以把后面的 32- 64 字节的数据也读取到"),v("code",[_._v("pageCache")]),_._v(" 中，如果在 32～64 KB 淘汰出 "),v("code",[_._v("PageCache")]),_._v(" 前，进程读取到它了，收益就非常大。")]),_._v(" "),v("p",[_._v("大文件的话就不要用这个零拷贝技术了，主要原因是 内存的空间小，如果一个大文件拷贝到内存中，我们的热点小文件就没办法被读到了；大文件可以采取 异步IO 的方式进行；")]),_._v(" "),v("h2",{attrs:{id:"io多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用"}},[_._v("#")]),_._v(" IO多路复用")]),_._v(" "),v("p",[v("strong",[_._v("一个进程来维护多个 "),v("code",[_._v("Socket")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png",alt:"img"}})]),_._v(" "),v("p",[_._v("我们熟悉的 "),v("code",[_._v("select/poll/epoll")]),_._v(" 内核提供给用户态的多路复用系统调用，进程可以通过"),v("strong",[_._v("一个系统调用函数从内核中获取多个事件")]),_._v("。这三个技术是"),v("strong",[_._v("如何获取网络事件")]),_._v("的呢？"),v("strong",[_._v("在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。")])]),_._v(" "),v("p",[v("code",[_._v("select")]),_._v(" 实现多路复用的方式：将已连接的 "),v("code",[_._v("Socket")]),_._v(" 都放在一个文件描述符集合（"),v("code",[_._v("BitsMap")]),_._v(" 大小为1024）中，然后调用 "),v("code",[_._v("select")]),_._v(" 函数将文件描述符集合拷贝到内核里，让内核检查是否有网络事件的发生，通过遍历的方式进行检查的，将有事件产生的进行标记为可读或者可写，然后将这个文件描述符集合从内核"),v("strong",[_._v("拷贝")]),_._v("回用户态，用户态再进行遍历，然后进行处理。"),v("code",[_._v("poll")]),_._v(" 其实也是差不多，只是换了数据结构，变成了一个动态数组，以链表的形式组织；")]),_._v(" "),v("p",[v("code",[_._v("epoll")]),_._v(" 解决了上面的 "),v("code",[_._v("select")]),_._v(" 以及 "),v("code",[_._v("poll")]),_._v(" 的问题，第一点：采用了"),v("strong",[_._v("红黑树来跟踪进程所有待检测的文件描述字")]),_._v("，把需要监控的 "),v("code",[_._v("socket")]),_._v(" 加入到内核的红黑树中，因为  "),v("code",[_._v("select")]),_._v(" 以及 "),v("code",[_._v("poll")]),_._v("  没有这种待检测的 "),v("code",[_._v("socket")]),_._v(" 的数据结构，所以每次操作都需要传入整个 "),v("code",[_._v("socket")]),_._v(" 集合给内核，而 "),v("code",[_._v("epoll")]),_._v(" 有这种待检测的红黑树结构，所需要只需要传入一个 待检测的 "),v("code",[_._v("socket")]),_._v(" 即可；第二点："),v("code",[_._v("epoll")]),_._v(" 采用"),v("strong",[_._v("事件驱动")]),_._v("机制，内核里"),v("strong",[_._v("维护了一个链表来记录就绪事件")]),_._v("，当某个 "),v("code",[_._v("socket")]),_._v(" 有事件发生的时候，通过"),v("strong",[_._v("回调函数内核")]),_._v("会将其加入到这个就绪事件列表中，最后用户会返回有事件发生的文件描述符个数即可，不需要扫描整个文件描述符集合；")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll.png",alt:"img"}})]),_._v(" "),v("p",[_._v("这里也了解一下这个事件触发模式：边缘触发以及这个水平触发；")]),_._v(" "),v("p",[_._v("边缘触发就是只有第一次满足事件的时候触发，之后都不会进行传递同样的事件了；水平触发的就是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；")]),_._v(" "),v("h2",{attrs:{id:"高性能网络模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#高性能网络模型"}},[_._v("#")]),_._v(" 高性能网络模型")]),_._v(" "),v("ul",[v("li",[_._v("Reactor 负责监听和分发事件，事件类型包括连接事件、读写事件；")]),_._v(" "),v("li",[_._v("处理资源池负责处理事件，如 read -> 业务逻辑 -> write")])]),_._v(" "),v("p",[_._v("三种方案：")]),_._v(" "),v("ul",[v("li",[_._v("单 Reactor 单进程 / 线程；")]),_._v(" "),v("li",[_._v("单 Reactor 多线程 / 进程；")]),_._v(" "),v("li",[_._v("多 Reactor 多进程 / 线程；")])]),_._v(" "),v("p",[_._v("第一个："),v("strong",[_._v("单 Reactor 单进程")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Reactor/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B.png",alt:"img"}})]),_._v(" "),v("ul",[v("li",[_._v("Reactor 对象作用是监听和分发事件；")]),_._v(" "),v("li",[_._v("Acceptor 负责建立连接；")]),_._v(" "),v("li",[_._v("Handler 负责处理业务")])]),_._v(" "),v("p",[_._v("两个缺点：①没用利用多核 "),v("code",[_._v("CPU")]),_._v(" 这个性能；"),v("code",[_._v("②Handler")]),_._v(" 对象业务处理的时候，整个进程是没有办法处理其他连接事件的，如果业务处理耗时长，响应会延迟。")]),_._v(" "),v("p",[_._v("单 "),v("code",[_._v("Reactor")]),_._v(" 单进程的方案"),v("strong",[_._v("不适用计算机密集型的场景，只适用于业务处理非常快速的场景")]),_._v("。比如说："),v("code",[_._v("Redis")])]),_._v(" "),v("p",[_._v("第二个："),v("strong",[_._v("单 Reactor 多进程")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Reactor/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png",alt:"img"}})]),_._v(" "),v("p",[_._v("这里和 单 "),v("code",[_._v("Reactor")]),_._v(" 单进程 有一个区别：就是 "),v("code",[_._v("Handler")]),_._v(" 不在处理业务，而是只是负责数据的接受和发送，将任务都交给了线程池的 "),v("code",[_._v("Processor")]),_._v(" 进行处理，处理完后，将结果发送给主线程的 "),v("code",[_._v("Handler")]),_._v(" 对象，接着由 "),v("code",[_._v("Handler")]),_._v(" 通过 "),v("code",[_._v("send")]),_._v(" 方法将结果发给 "),v("code",[_._v("client")]),_._v("。")]),_._v(" "),v("p",[_._v("「单 "),v("code",[_._v("Reactor")]),_._v("」的模式还有个问题，"),v("strong",[_._v("因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方")])]),_._v(" "),v("p",[_._v("第三个："),v("strong",[_._v("多 Reactor 多进程")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Reactor/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png",alt:"img"}})]),_._v(" "),v("p",[_._v("方案详细说明如下 ：")]),_._v(" "),v("ul",[v("li",[_._v("主线程中的 "),v("code",[_._v("MainReactor")]),_._v(" 对象通过 "),v("code",[_._v("select")]),_._v(" 监控连接建立事件，收到事件后通过 "),v("code",[_._v("Acceptor")]),_._v(" 对象中的 "),v("code",[_._v("accept")]),_._v(" 获取连接，将新的连接分配给某个子线程；")]),_._v(" "),v("li",[_._v("子线程中的 "),v("code",[_._v("SubReactor")]),_._v(" 对象将 "),v("code",[_._v("MainReactor")]),_._v(" 对象分配的连接加入 "),v("code",[_._v("select")]),_._v(" 继续进行监听，并创建一个 "),v("code",[_._v("Handler")]),_._v(" 用于处理连接的响应事件。")]),_._v(" "),v("li",[_._v("如果有新的事件发生时，"),v("code",[_._v("SubReactor")]),_._v(" 对象会调用当前连接对应的 "),v("code",[_._v("Handler")]),_._v(" 对象来进行响应。")]),_._v(" "),v("li",[v("code",[_._v("Handler")]),_._v(" 对象通过 "),v("code",[_._v("read")]),_._v(" -> 业务处理 -> "),v("code",[_._v("send")]),_._v(" 的流程来完成完整的业务流程。")])]),_._v(" "),v("p",[_._v("实际的项目就是有："),v("code",[_._v("Netty")]),_._v("、"),v("code",[_._v("Memcache")])]),_._v(" "),v("p",[v("code",[_._v("Reactor")]),_._v(" 是非阻塞的同步网络模式，而 "),v("code",[_._v("Proactor")]),_._v(" 是异步网络模式。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("阻塞：典型的就是我们阻塞 "),v("code",[_._v("BIO")]),_._v(" 了，当我们进行 "),v("code",[_._v("read()")]),_._v(" 时，线程会被阻塞，直到我们内核数据准备好了，并把内核数据拷贝到我们的应用程序缓冲区，拷贝完成后，这个 "),v("code",[_._v("read()")]),_._v(" 才进行返回。")]),_._v(" "),v("p",[_._v("注意："),v("strong",[_._v("阻塞等待就是【内核数据准备好】和【数据从内核缓冲区拷贝到应用程序缓冲区】这两个过程")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%98%BB%E5%A1%9E%20I_O.png",alt:"阻塞 I/O"}})])]),_._v(" "),v("li",[v("p",[_._v("非阻塞：典型就是我们的 "),v("code",[_._v("NIO")]),_._v(" 了，非阻塞的 "),v("code",[_._v("read()")]),_._v(" 请求在数据未准备好的情况下就立即返回，可以继续往下执行，此时应用程序不断轮询这个内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，"),v("code",[_._v("read()")]),_._v(" 调用才获取到结果。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E9%98%BB%E5%A1%9E%20I_O%20.png",alt:"非阻塞 I/O"}})]),_._v(" "),v("p",[_._v("但是，注意："),v("strong",[_._v("这里最后一次 read() 调用，获取数据的过程是一个同步的过程，需要进行等待，这里的同步指的是内核态的数据拷贝到用户程序的缓冲区这个过程。")])]),_._v(" "),v("p",[_._v("因此，无论是 "),v("code",[_._v("read")]),_._v(" 还是 "),v("code",[_._v("send")]),_._v(" 是阻塞 IO，还是非阻塞IO 都是同步调用的。因为在 "),v("code",[_._v("read")]),_._v(" 调用时，内核将数据从内核空间拷贝到用户空间这个过程都是需要进行等待的，也就是这个过程是同步的；")])])]),_._v(" "),v("p",[_._v("**而真正的异步 IO 是【数据在内核准备好】和【数据从内核空间拷贝到用户应用程序缓冲区】两个空间都是不需要等待的； ** "),v("strong",[_._v("应用程序不需要自己主动发出拷贝数据的动作。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5%20I_O.png",alt:"异步 I/O"}})]),_._v(" "),v("p",[v("code",[_._v("Reactor")]),_._v(" 以及 "),v("code",[_._v("Proactor")]),_._v(" 区别：")]),_._v(" "),v("ul",[v("li",[v("strong",[v("code",[_._v("Reactor")]),_._v(" 是非阻塞同步网络模式，感知的是就绪可读写事件")]),_._v("；即在每次感知有事件发生后，就需要应用程序主动调用 "),v("code",[_._v("read")]),_._v(" 方法进行完成数据的读取，也就是需要应用进程主动将 "),v("code",[_._v("socket")]),_._v(" 接受缓存中的数据读到应用程序中的内存来，这个过程是同步的，读取完数据后才能进行处理；")]),_._v(" "),v("li",[v("strong",[v("code",[_._v("Proactor")]),_._v(" 是非阻塞异步网络模式，感知的是已完成的读写事件")]),_._v("；总的来说，在发起异步读写请求后，就是统统不用干，等 "),v("code",[_._v("OS")]),_._v(" 来通知我们应用程序直接处理数据。")]),_._v(" "),v("li",[_._v("其实两者都是基于【事件分发】的网络编程模式。")])])])}),[],!1,null,null,null);v.default=c.exports}}]);