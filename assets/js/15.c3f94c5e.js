(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{405:function(a,v,_){"use strict";_.r(v);var t=_(2),e=Object(t.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"hashmap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),v("h3",{attrs:{id:"红黑树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#红黑树"}},[a._v("#")]),a._v(" 红黑树")]),a._v(" "),v("p",[a._v("在 "),v("code",[a._v("HashMap")]),a._v(" 中，红黑树的作用是为了提高查询效率的，先不说特点，先说他的应用：")]),a._v(" "),v("ul",[v("li",[a._v("当链表长度大于 8 && 数组的长度大于等于 64 的时候，该链就会演变成红黑树了；")]),a._v(" "),v("li",[a._v("然后当红黑树节点个数小于 6，就会退化成这个链表")])]),a._v(" "),v("p",[a._v("红黑树的特点：")]),a._v(" "),v("ul",[v("li",[a._v("节点要么是黑色要么是红色；")]),a._v(" "),v("li",[a._v("根节点一定是黑色；")]),a._v(" "),v("li",[a._v("红色节点的两个子节点一定是黑色（即不可能出现两个相邻的红色节点）；")]),a._v(" "),v("li",[a._v("所有的叶子节点都是黑色的（叶子节点是 "),v("code",[a._v("null")]),a._v(" 节点）；")]),a._v(" "),v("li",[a._v("从任一节点出发到每个叶子的所有的路径都包含相同数目的黑色节点；")])]),a._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d6347b92cbc45ab9ebc077467699c2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",alt:"红黑树"}})]),a._v(" "),v("h3",{attrs:{id:"为什么不用二叉树-那为什么不用平衡树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不用二叉树-那为什么不用平衡树"}},[a._v("#")]),a._v(" 为什么不用二叉树？那为什么不用平衡树？")]),a._v(" "),v("p",[a._v("红黑树是一种平衡的二叉树，增删改查最坏的时间复杂度都是 "),v("code",[a._v("O(logn)")]),a._v("，避免了二叉树最坏的情况 "),v("code",[a._v("O(n)")])]),a._v(" "),v("p",[a._v("为什么不用平衡二叉树的原因在于平衡二叉树是一个比红黑树更加严格的平衡树，为了保持平衡需要旋转更多的次数，也就是说平衡二叉树保持平衡的效率更低（从平衡二叉树"),v("strong",[a._v("插入和删除")]),a._v("的效率比红黑树要低）。")]),a._v(" "),v("h3",{attrs:{id:"红黑树如何保持平衡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#红黑树如何保持平衡"}},[a._v("#")]),a._v(" 红黑树如何保持平衡？")]),a._v(" "),v("p",[a._v("染色和旋转")]),a._v(" "),v("h3",{attrs:{id:"put-get-流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#put-get-流程"}},[a._v("#")]),a._v(" put() get() 流程？")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/329d9e53605d4579b2fc47cf9e9932c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",alt:"HashMap插入数据流程图"}})]),a._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b007ed816fa477394fa231b5b6c16b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",alt:"HashMap查找流程图"}})]),a._v(" "),v("h3",{attrs:{id:"hashmap的扰动函数如何设计的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的扰动函数如何设计的"}},[a._v("#")]),a._v(" HashMap的扰动函数如何设计的？")]),a._v(" "),v("p",[a._v("如果 "),v("code",[a._v("key")]),a._v(" 为 "),v("code",[a._v("null")]),a._v(" 的时候就是为0；不为 "),v("code",[a._v("null")]),a._v(" 的时候就是 "),v("code",[a._v("key.hashcode() ^ (h >>> 16)")])]),a._v(" "),v("h3",{attrs:{id:"解决-哈希冲突的办法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决-哈希冲突的办法"}},[a._v("#")]),a._v(" 解决 哈希冲突的办法")]),a._v(" "),v("ul",[v("li",[a._v("拉链法")]),a._v(" "),v("li",[a._v("开放定址：就是从冲突的位置再接着往下找，给冲突元素找个空位")]),a._v(" "),v("li",[a._v("再哈希法：换一个哈希函数，重新计算冲突元素的地址")]),a._v(" "),v("li",[a._v("建立公共溢出区：再建一个数组，把冲突的元素放进去")])]),a._v(" "),v("h3",{attrs:{id:"hashmap链表转红黑树的阈值为什么是8"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashmap链表转红黑树的阈值为什么是8"}},[a._v("#")]),a._v(" HashMap链表转红黑树的阈值为什么是8？")]),a._v(" "),v("p",[a._v("红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。")]),a._v(" "),v("p",[a._v("为什么要选择8是因为链表的节点符合泊松分布，就是说，桶里的元素都是比较均匀的，很少情况下会出现某一个桶的节点个数很多的情况；将阈值设置为8可以确保大多数桶都能保持较低的节点数量，而只有少数桶会超过这个值；")]),a._v(" "),v("p",[a._v("至于为什么红黑树转回链表的阈值是6，那是因为临界值嘛，你一会变为链表一会变为红黑树，效率低。")]),a._v(" "),v("h3",{attrs:{id:"扩容机制了解吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#扩容机制了解吗"}},[a._v("#")]),a._v(" 扩容机制了解吗")]),a._v(" "),v("p",[v("code",[a._v("HashMap")]),a._v(" 的初始容量是2的次幂，扩容之后的长度是原来的2倍，新的容量也是2的次幂，所以元素要么在原位置，要么就是在 "),v("strong",[a._v("原位置 + "),v("code",[a._v("oldCap")])]),a._v(" 位置上。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4c334f823834899977a03130e10663d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",alt:"扩容节点迁移示意图"}})]),a._v(" "),v("h3",{attrs:{id:"hashmap-是安全的嘛-多线程下有啥问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-是安全的嘛-多线程下有啥问题"}},[a._v("#")]),a._v(" HashMap 是安全的嘛？多线程下有啥问题？")]),a._v(" "),v("ul",[v("li",[a._v("多线程的 "),v("code",[a._v("put")]),a._v(" 可能导致线程会丢失，前一个线程 "),v("code",[a._v("put")]),a._v(" 的元素，可能会被后一个线程给覆盖掉；")]),a._v(" "),v("li",[a._v("同时，"),v("code",[a._v("put")]),a._v(" 和 "),v("code",[a._v("get")]),a._v(" 并发操作的时候，原本有的元素变成了 "),v("code",[a._v("null")]),a._v("；线程1 执行 "),v("code",[a._v("put")]),a._v(" 时，因为元素个数超出了 "),v("code",[a._v("threshold")]),a._v(" 而导致 "),v("code",[a._v("rehash")]),a._v("，线程2 此时执行 "),v("code",[a._v("get")]),a._v("，有可能导致这个问题；")])]),a._v(" "),v("h3",{attrs:{id:"如何保证hashmap的线程安全性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何保证hashmap的线程安全性"}},[a._v("#")]),a._v(" 如何保证HashMap的线程安全性？")]),a._v(" "),v("ul",[v("li",[v("code",[a._v("HashTable")])]),a._v(" "),v("li",[v("code",[a._v("Collections.synchronizedMap")])]),a._v(" "),v("li",[v("code",[a._v("ConcurrentHashmap")])])]),a._v(" "),v("h3",{attrs:{id:"linkedhashmap-如何实现有序的-treemap-怎么实现有序的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap-如何实现有序的-treemap-怎么实现有序的"}},[a._v("#")]),a._v(" LinkedHashMap 如何实现有序的？TreeMap 怎么实现有序的")]),a._v(" "),v("p",[v("code",[a._v("LinkedHashMap")]),a._v(" 维护了一个双向链表，有头尾节点，同时 "),v("code",[a._v("LinkedHashMap")]),a._v(" 节点 "),v("code",[a._v("Entry")]),a._v(" 内部除了继承这个 "),v("code",[a._v("HashMap")]),a._v(" 的 "),v("code",[a._v("Node")]),a._v(" 属性，还有 "),v("code",[a._v("before")]),a._v(" 和 "),v("code",[a._v("after")]),a._v(" 用于标识前置节点和后置节点。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d884fc860524fe68cbf7fd931ee0f8e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",alt:"Entry节点"}})]),a._v(" "),v("p",[a._v("而我们的 "),v("code",[a._v("TreeMap")]),a._v(" 的话，是按照 "),v("code",[a._v("Key")]),a._v(" 的自然顺序或者 "),v("code",[a._v("Comprator")]),a._v(" 的顺序进行排序的，内部是通过红黑树来实现的；所以要么 "),v("code",[a._v("Key")]),a._v(" 所属的类实现  "),v("code",[a._v("Comparable")]),a._v(" 接口，要么自定义一个比较器来传给 "),v("code",[a._v("TreeMap")]),a._v(" 用于 "),v("code",[a._v("Key")]),a._v(" 的排序。")]),a._v(" "),v("h2",{attrs:{id:"concurrenthashmap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),v("h3",{attrs:{id:"put-流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#put-流程"}},[a._v("#")]),a._v(" put 流程")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9db1321d22ff4857b7112a5653978dd6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",alt:"ConcurrentHashmap jdk1.8put流程"}})]),a._v(" "),v("h3",{attrs:{id:"为什么写入数据的时候用的-synchronized-而不用-cas-呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么写入数据的时候用的-synchronized-而不用-cas-呢"}},[a._v("#")]),a._v(" 为什么写入数据的时候用的 synchronized 而不用 CAS 呢？")]),a._v(" "),v("p",[a._v("我们知道 "),v("code",[a._v("CAS")]),a._v(" + 自旋操作来进行的，也就是说不挂起线程继续使用 "),v("code",[a._v("CPU")]),a._v(" 的执行时间，一般在竞争不激烈的时候好用；")]),a._v(" "),v("p",[a._v("在 "),v("code",[a._v("putVal()")]),a._v(" 方法中，如果计算出来的槽是没有存放元素的，直接使用 "),v("code",[a._v("CAS")]),a._v(" 来进行设置值，那是因为设置元素的时候，"),v("code",[a._v("hash")]),a._v(" 值经过了各种的扰动后，造成 "),v("code",[a._v("hash")]),a._v(" 碰撞的几率低，那么我们可以直接使用较少的自旋来完成具体的 "),v("code",[a._v("hash")]),a._v(" 落槽操作；")]),a._v(" "),v("p",[a._v("当发生了 "),v("code",[a._v("hash")]),a._v(" 碰撞的时候就说明了容量不够用了或者已经有大量的线程访问了，因此这时候使用 "),v("code",[a._v("synchronized")]),a._v(" 处理会效率高；因为发生了 "),v("code",[a._v("hash")]),a._v(" 碰撞大概率来说是线程竟争比较强烈了。")]),a._v(" "),v("h2",{attrs:{id:"list"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[a._v("#")]),a._v(" List")]),a._v(" "),v("h3",{attrs:{id:"快速失败-fail-fast-和-安全失败-fail-safe-了解吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#快速失败-fail-fast-和-安全失败-fail-safe-了解吗"}},[a._v("#")]),a._v(" 快速失败（fail-fast）和 安全失败（fail-safe）了解吗？")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("快速失败（fail-fast）")]),a._v(" "),v("p",[a._v("快速失败是 "),v("code",[a._v("Java")]),a._v(" 集合的一种错误检测机制")]),a._v(" "),v("ul",[v("li",[a._v("在用迭代器遍历集合对象的时候，如果线程A遍历过程中，线程B对集合对象进行修改，就会抛出 "),v("code",[a._v("Concurrent Modification Exception")])]),a._v(" "),v("li",[a._v("原理：迭代器在遍历时直接访问集合中的内容，并且在遍历的工程中会使用一个 "),v("code",[a._v("modCount")]),a._v(" 变量，集合在被遍历期间如果内容发生变化，就会修改这个 "),v("code",[a._v("modCount")]),a._v(" 值，每当迭代器进行 "),v("code",[a._v("hashNext()/next()")]),a._v(" 遍历下一个元素之前，都会检测 "),v("code",[a._v("modCount")]),a._v(" 是否等于 "),v("code",[a._v("expectmodCount")]),a._v("，相等则返回遍历，不相等则抛出异常终止遍历；")]),a._v(" "),v("li",[a._v("场景："),v("code",[a._v("java.util")]),a._v("包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如 "),v("code",[a._v("ArrayList")]),a._v(" 类。")])])]),a._v(" "),v("li",[v("p",[a._v("安全失败（fail-safe）")]),a._v(" "),v("p",[a._v("采用安全失败机制的集合，在遍历时不是直接在集合内容上访问的，而是先复制原有集合的内容，在拷贝集合上进行遍历；")]),a._v(" "),v("ul",[v("li",[a._v("原理：由于迭代时是对集合的拷贝进行遍历，所以遍历过程中对原来的集合作的修改检测器无法检测到的，所以就不会有这个 "),v("code",[a._v("Concurrent Modification Exception")])]),a._v(" "),v("li",[a._v("缺点：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间集合发生的修改迭代器是没办法知道的；")]),a._v(" "),v("li",[a._v("场景："),v("code",[a._v("java.util.concurrent")]),a._v(" 包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如"),v("code",[a._v("CopyOnWriteArrayList")]),a._v(" 类。")])])])]),a._v(" "),v("h2",{attrs:{id:"set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[a._v("#")]),a._v(" Set")]),a._v(" "),v("p",[a._v("去重。。。。")])])}),[],!1,null,null,null);v.default=e.exports}}]);