(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{418:function(_,v,o){"use strict";o.r(v);var t=o(2),r=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"虚拟内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[_._v("#")]),_._v(" 虚拟内存")]),_._v(" "),v("p",[_._v("我们的 "),v("code",[_._v("CPU")]),_._v(" 是可以直接操作物理内存的，但是这样很危险啊，这就会造就内存中不可能同时运行两个程序；")]),_._v(" "),v("p",[_._v("总的来说："),v("strong",[_._v("操作系统引入了虚拟内存，进程持有的虚拟内存会通过 "),v("code",[_._v("CPU")]),_._v(" 芯片中的内存管理单元（"),v("code",[_._v("MMU")]),_._v("）的映射关系来进行转换成物理地址，然后再通过物理地址来访问内存。")])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png",alt:"img"}})]),_._v(" "),v("p",[_._v("那问题来了，操作系统是如何管理虚拟内存和物理内存之间的关系的？内存分页、内存分段、段页式管理")]),_._v(" "),v("h3",{attrs:{id:"os如何管理虚拟内存和物理内存之间的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#os如何管理虚拟内存和物理内存之间的关系"}},[_._v("#")]),_._v(" OS如何管理虚拟内存和物理内存之间的关系")]),_._v(" "),v("ul",[v("li",[v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com//mysql/other/c5e2ab63e6ee4c8db575f3c7c9c85962.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("内存分段"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/c5e2ab63e6ee4c8db575f3c7c9c85962.png",alt:"img"}})]),_._v(" "),v("p",[_._v("可以记住我们内存分段的结构，是通过 【段基地址】和【段界限】来进行映射到我们的物理地址的；当 "),v("code",[_._v("CPU")]),_._v(" 通过段号找到我们的段基地址后，然后在加上段界限来找到我们的物理地址；")]),_._v(" "),v("p",[_._v("但是有缺点：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("图中我们都可以看到，有可能"),v("strong",[_._v("导致内存碎片问题")]),_._v("；因为每个段的长度不固定，所以多个段未必能恰好能使用所有的内存空间，从而导致多个不连续的小物理内存，导致新的程序无法被加载（原本多个不连续的物理内存是可以加载的）；")])]),_._v(" "),v("li",[v("p",[_._v("第二个就是"),v("strong",[_._v("有可能导致内存交换的效率低")]),_._v("的问题；我们知道，解决外部内存碎片问题是使用"),v("strong",[_._v("内存交换")]),_._v("；可以把第一个程序占用的内存写回到硬盘，然后再从硬盘中读取到内存；但是此时内存中原本属于第一个程序的内存被占用了，那么就紧跟着第二个硬盘的空间上进行加载即可。")]),_._v(" "),v("p",[_._v("这个内存交换空间，在 "),v("code",[_._v("Linux")]),_._v(" 系统里，也就是我们常看到的 "),v("code",[_._v("Swap")]),_._v(" 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。")]),_._v(" "),v("p",[_._v("但是这样恰恰带来了问题，因为磁盘的访问速度比这个内存慢多了，所以每一次的内存交换，都需要把一大段连续的内存数据写到磁盘中；"),v("strong",[_._v("如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。")])])])])]),_._v(" "),v("li",[v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("内存分页"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("strong",[_._v("分页就是把整个虚拟和物理内存空间切成一段段固定尺寸大小")]),_._v("；这样一个连续并且尺寸固定的内存空间，我们叫"),v("strong",[_._v("页")]),_._v("；在 "),v("code",[_._v("Linux")]),_._v(" 下，我们的页固定大小为 4 KB。")]),_._v(" "),v("p",[_._v("当进程访问的虚拟地址在页表中查不到时，系统会产生一个"),v("strong",[_._v("缺页异常")]),_._v("，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行；")]),_._v(" "),v("p",[_._v("分页如何解决内存交换效率低的问题？")]),_._v(" "),v("p",[_._v("如果磁盘内存空间不足；OS 会将其他正在运行的进程中的【最近没被使用】的内存页面给释放掉，也就是暂时写在磁盘上，等到需要的时候在进行加载到我们的内存中；所以一次性写入磁盘的也只有少数的一个页或者几个页，内存交换效率就高了；")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/388a29f45fe947e5a49240e4eff13538-20230309234651917.png",alt:"img"}})]),_._v(" "),v("p",[_._v("更进一步，我们不需要一次性把"),v("strong",[_._v("程序加载到物理内存")]),_._v("中；"),v("strong",[_._v("我们完全可以只有在程序运行时，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。")])]),_._v(" "),v("p",[_._v("分页机制下，虚拟地址和物理地址如何映射？")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("图片展示"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png",alt:"img"}})]),_._v(" "),v("p",[_._v("结构有 "),v("strong",[_._v("页号")]),_._v("和"),v("strong",[_._v("页内偏移")]),_._v("；"),v("strong",[_._v("页号代表页表的索引")]),_._v("，页表包含"),v("strong",[_._v("物理页每页所在物理内存的基地址（也就是物理页号）")]),_._v("，这个"),v("strong",[_._v("基地址和页内偏移的组合形成了物理内存地址")]),_._v("；")]),_._v(" "),v("p",[_._v("步骤：虚拟内存被切分为页号和页内偏移量；然后根据页号找到了页表的对应的物理页号；然后直接拿物理页号加上页内偏移量，就得到了物理内存地址。")])]),_._v(" "),v("li",[v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png",target:"_blank",rel:"noopener noreferrer"}},[v("code",[_._v("TLB")]),v("OutboundLink")],1),_._v("（"),v("code",[_._v("Translation Lookasde Buffer")]),_._v("）")]),_._v(" "),v("p",[_._v("也叫做页表缓存，快表等")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png",alt:"img"}})]),_._v(" "),v("p",[_._v("在 "),v("code",[_._v("CPU")]),_._v(" 芯片里面，封装了 "),v("code",[_._v("MMU")]),_._v(" 芯片，它用来完成地址转换和 "),v("code",[_._v("TLB")]),_._v(" 的访问与交互；有了 "),v("code",[_._v("TLB")]),_._v("，在 "),v("code",[_._v("CPU")]),_._v(" 寻址时，会查 "),v("code",[_._v("TLB")]),_._v("，如果没找到才会继续查常规的页表。")])]),_._v(" "),v("li",[v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("段页内存管理"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png",alt:"img"}})]),_._v(" "),v("p",[_._v("段页式地址变换中要得到物理地址需要三次内存访问：")]),_._v(" "),v("ol",[v("li",[_._v("第一次访问段表，得到"),v("strong",[_._v("页表起始地址")]),_._v("；")]),_._v(" "),v("li",[_._v("第二次访问页表，得到"),v("strong",[_._v("物理页号")]),_._v("；")]),_._v(" "),v("li",[_._v("第三次"),v("strong",[_._v("将物理页号和页内偏移量组合")]),_._v(" ，得到物理地址。")])])]),_._v(" "),v("li",[v("p",[_._v("虚拟内存的作用")]),_._v(" "),v("ol",[v("li",[_._v("使得一个计算机可以同时运行多个程序嘛，保证了多进程不冲突；如何保证的就是上面虚拟内存和物理内存如何映射可以看出；")]),_._v(" "),v("li",[_._v("使得进程运行内存超过物理内存的大小；因为程序运行符合局部性原理，CPU 访问内存会有明显的重复访问的倾向，对于没有经常被访问到的内存，我们可以把它换出物理内存之外，比如磁盘上的 "),v("code",[_._v("Swap")]),_._v(" 区域")])])])]),_._v(" "),v("h2",{attrs:{id:"进程管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程管理"}},[_._v("#")]),_._v(" 进程管理")]),_._v(" "),v("p",[_._v("进程管理一个很重要的知识点，就是上下文切换，然后我们还需要理解一个知识，就是系统调用，然后了解一下线程调度算法是啥？")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("什么是系统调用")]),_._v(" "),v("p",[_._v("把进程在系统上的运行分为两个级别，我们首先要了解用户态和内核态这两个玩意；进程在系统上的运行分为两个级别；")]),_._v(" "),v("p",[v("strong",[_._v("用户态")]),_._v("运行的进程可以直接读取用户程序的数据，拥有较低的权限；比如读写磁盘，网络通信这些都需要，都"),v("strong",[_._v("需要向 "),v("code",[_._v("OS")]),_._v(" 发起系统调用请求，进入内核态")]),_._v("；")]),_._v(" "),v("p",[v("strong",[_._v("内核态")]),_._v("运行的进程可以访问计算机任何的资源；当 "),v("code",[_._v("OS")]),_._v(" 接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换到用户态。")])]),_._v(" "),v("li",[v("p",[_._v("系统调用会涉及到上下文切换")]),_._v(" "),v("p",[_._v("那什么是上下文切换？一个任务切换到另一个任务的运行，成为上下文切换，其中任务可以分为【进程】【线程】【中断】；")]),_._v(" "),v("p",[_._v("那好，我们先来看看 "),v("code",[_._v("CPU")]),_._v(" 上下文切换：")]),_._v(" "),v("p",[_._v("我们的进程都是运行在 "),v("code",[_._v("CPU")]),_._v(" 上的，那么在每个任务执行前，"),v("code",[_._v("CPU")]),_._v(" 需要知道任务从哪里加载，又从哪里开始运行；所以 "),v("code",[_._v("OS")]),_._v(" 需要"),v("strong",[_._v("事先帮 "),v("code",[_._v("CPU")]),_._v(" 设置好 "),v("code",[_._v("CPU")]),_._v(" 的寄存器和程序计数器")]),_._v("；（"),v("strong",[v("code",[_._v("CPU")]),_._v(" 寄存器")]),_._v("相当于你的口袋，内存相当于你的书包，磁盘相当于你的 柜子；"),v("strong",[_._v("程序计数器")]),_._v("相当于用来存储 "),v("code",[_._v("CPU")]),_._v(" 正在执行的指令位置，或者即将执行的下一条指令位置）")]),_._v(" "),v("p",[_._v("所以 "),v("strong",[v("code",[_._v("CPU")]),_._v(" 上下文切换")]),_._v("就是先把"),v("strong",[_._v("上一个任务的 "),v("code",[_._v("CPU")]),_._v(" 上下文（"),v("code",[_._v("CPU")]),_._v(" 寄存器和程序计数器）保存起来，然后加载新任务的上下文保存到当前的寄存器和程序计数器，最后跳转到程序计数器指定的位置继续运行即可")]),_._v("；")]),_._v(" "),v("p",[_._v("我们的 "),v("code",[_._v("CPU")]),_._v(" 的上下文是程序计数器和寄存器，那"),v("strong",[_._v("我们的进程的上下文是啥")]),_._v("？"),v("strong",[_._v("就是虚拟内存、栈、全局变量等用户空间资源，还包括了内核堆栈、寄存器等内核空间的资源。")])]),_._v(" "),v("p",[v("strong",[_._v("线程的上下文就是自己的私有数据以及寄存器等不共享的数据即可；")])]),_._v(" "),v("p",[_._v("补充：进程上下文切换的使用场景：① "),v("code",[_._v("CPU")]),_._v(" 分配的时间片用完了；②进程通过 "),v("code",[_._v("sleep")]),_._v(" 函数将自己主动挂起；③有更高级别的进程执行，就退位；⑥系统的内存空间不足，也会挂起；")])]),_._v(" "),v("li",[v("p",[_._v("进程间通信有哪些？")]),_._v(" "),v("p",[_._v("进程间的通信是一个"),v("strong",[_._v("递进")]),_._v("的一个过程：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("匿名管道")]),_._v(" "),v("p",[_._v("存在于父子进程，子进程会复制父进程的文件描述符，也"),v("strong",[_._v("只能在父子进程之间进程通信")]),_._v("；")])]),_._v(" "),v("li",[v("p",[_._v("命名管道")]),_._v(" "),v("p",[_._v("可以在"),v("strong",[_._v("毫无关系的两个管道上进行通信")]),_._v("，"),v("strong",[_._v("提前创建")]),_._v("了一个类型为"),v("strong",[_._v("管道的设备文件")]),_._v("，在进程里只要使用这个设备文件就可以互相通信；")]),_._v(" "),v("p",[_._v("但是缺点是不支持定位读取消息，不适合频繁读取数据的操作；")])]),_._v(" "),v("li",[v("p",[_._v("消息队列")]),_._v(" "),v("p",[_._v("存储在内核的消息链表，生命周期不随进程有关；但是有两个缺点：数据大小有限制，不适合大数据的传输；存在用户态和内核态的拷贝，即系统调用嘛")])]),_._v(" "),v("li",[v("p",[_._v("共享内存")]),_._v(" "),v("p",[_._v("拿出一块虚拟内存作为共享内存空间，但是又带来了数据冲突的问题")])]),_._v(" "),v("li",[v("p",[_._v("信号量")]),_._v(" "),v("p",[_._v("不是一种通信方式，而是一种保证进程之间同步互斥以及数据安全的方式；用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据；")])]),_._v(" "),v("li",[v("p",[_._v("信号")]),_._v(" "),v("p",[_._v("对于"),v("strong",[_._v("异常情况下")]),_._v("的工作模式，需要用【信号】的方式通知进程，信号是进程间通信机制中"),v("strong",[_._v("唯一的异步通信机制；")])])]),_._v(" "),v("li",[v("p",[v("code",[_._v("Socket")])]),_._v(" "),v("p",[_._v("跨越网络和不同主机实现通信，需要用到 "),v("code",[_._v("Socket")]),_._v(" 。")])])])])]),_._v(" "),v("h2",{attrs:{id:"调度算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调度算法"}},[_._v("#")]),_._v(" 调度算法")]),_._v(" "),v("p",[_._v("了解一下先来先服务算法、短作业优先算法、多级反馈队列调度算法")]),_._v(" "),v("ul",[v("li",[v("p",[v("a",{attrs:{href:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg",target:"_blank",rel:"noopener noreferrer"}},[_._v("多级反馈队列调度算法"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg",alt:"多级反馈队列"}})]),_._v(" "),v("p",[_._v("如何工作？")]),_._v(" "),v("ol",[v("li",[_._v("设置了多个队列，每个队列不同的优先级，每个"),v("strong",[_._v("队列优先级从高到低")]),_._v("，同时"),v("strong",[_._v("优先级越高时间片越短")]),_._v("；")]),_._v(" "),v("li",[v("strong",[_._v("新的继承会被放在第一级队列的末尾")]),_._v("，按"),v("strong",[_._v("先来先服务的原则排队")]),_._v("等待被调度，如果在第一梯队列规定的时间片内没完成，则将其转入第二梯队队列的末尾，以此类推。。")]),_._v(" "),v("li",[_._v("当较高优先级的队列为空，才调度较低优先级的队列中的进程运行；"),v("strong",[_._v("当较高优先级的队列有任务了，就立即停止当前的任务并将任务转移到原队列的末尾，转而去执行较高优先级的进程。")])])])])]),_._v(" "),v("h2",{attrs:{id:"其他"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[_._v("#")]),_._v(" 其他")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("线程和进程和协程的区别")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("最大的区别")]),_._v("：进程是 "),v("code",[_._v("OS")]),_._v(" 资源分配的最小单位，线程是 "),v("code",[_._v("CPU")]),_._v(" 调度的基本单位；")]),_._v(" "),v("li",[_._v("进程拥有完整的资源，而线程只含有必不可少的资源，比如寄存器和栈")]),_._v(" "),v("li",[_._v("线程创建和销毁的时间和空间开销都小于进程；\n"),v("ul",[v("li",[_._v("进程创建和线程创建不一样，线程只需要创建自己独有的，贡献堆啊，全局变量啊等资源；")]),_._v(" "),v("li",[_._v("进程的通信方式都比较复杂；线程通过共享内存和文件资源等进程的东西；")]),_._v(" "),v("li",[_._v("线程的上下文切换开销也比进程的小多了。")])])])]),_._v(" "),v("p",[_._v("协程：是一种"),v("strong",[_._v("轻量级的线程")]),_._v("，也被称为"),v("strong",[_._v("用户级线程")]),_._v("；")]),_._v(" "),v("p",[_._v("应用场景：协程在异步编程中广泛应用：例如使用协程可以实现高效网络通信，数据库访问等；")]),_._v(" "),v("p",[_._v("任务调度：协程可以应用任务调度，例如在"),v("strong",[_._v("事件驱动的系统中")]),_._v("，"),v("strong",[_._v("协程可以处理事件并进行任务切换")]),_._v("；")]),_._v(" "),v("p",[_._v("大数据处理：在"),v("strong",[_._v("数据流处理")]),_._v("中，可以"),v("strong",[_._v("实现数据的流水线处理")]),_._v("；")]),_._v(" "),v("p",[_._v("协程的实现方式："),v("code",[_._v("Java")]),_._v(" 的 "),v("code",[_._v("Coroutine")]),_._v(" 库等；")])]),_._v(" "),v("li",[v("p",[v("a",{attrs:{href:"https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/state-transition-of-process.png",target:"_blank",rel:"noopener noreferrer"}},[_._v("线程和进程的状态"),v("OutboundLink")],1)])])])])}),[],!1,null,null,null);v.default=r.exports}}]);