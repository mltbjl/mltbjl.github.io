(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{445:function(e,v,t){"use strict";t.r(v);var _=t(2),a=Object(_.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"序言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#序言"}},[e._v("#")]),e._v(" 序言")]),e._v(" "),v("p",[e._v("下文锁的内容参考自美团技术开发团队的 "),v("a",{attrs:{href:"https://tech.meituan.com/2018/11/15/java-lock.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("不可不说的Java“锁”事"),v("OutboundLink")],1),e._v(" 以及 "),v("a",{attrs:{href:"https://juejin.cn/post/7052558816671449096#heading-34",target:"_blank",rel:"noopener noreferrer"}},[e._v("三分恶"),v("OutboundLink")],1)]),e._v(" "),v("h2",{attrs:{id:"线程状态以及更改"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程状态以及更改"}},[e._v("#")]),e._v(" 线程状态以及更改")]),e._v(" "),v("p",[e._v("有哪几种线程状态？分别如何转换？")]),e._v(" "),v("p",[e._v("Start Ready Running Blocked Terminate")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://blog.csdn.net/xzp_12345/article/details/81127384",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片来源"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdn.net/2018072010171578?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h6cF8xMjM0NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70",alt:"img"}})]),e._v(" "),v("h2",{attrs:{id:"锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[e._v("#")]),e._v(" 锁")]),e._v(" "),v("p",[e._v("乐观锁：当前线程认为自己使用数据时不会有别的线程进行修改，所以不需要添加锁；只是在更新数据的时候会先判断主存中的数据是否被其他线程修改过，如果没修改过则直接写入；否则重新检查数据；Java 实现乐观锁的方式为使用了 CAS + 自旋操作；同时 Java 中的原子类操作就是根据这个 CAS 自旋实现的；")]),e._v(" "),v("p",[e._v("悲观锁：当前线程在进行使用数据的时候认为一定有其他线程进行数据的修改，因此在获取数据的时候会先加锁，确保数据不会被其他线程修改；Java 典型的操作就是 "),v("code",[e._v("synchronized")]),e._v(" 以及 "),v("code",[e._v("ReentranLock")])]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("从上面的描述可以知道")]),e._v(" "),v("ul",[v("li",[e._v("悲观锁适合写操作多的场景，先加锁可以保证写数据的时候正确；")]),e._v(" "),v("li",[e._v("乐观锁适合读操作多的场景，不加锁的特点能够使其操作的性能大大提升；")])]),e._v(" "),v("p",[e._v("乐观锁的实现方式："),v("code",[e._v("CAS")])]),e._v(" "),v("p",[v("code",[e._v("CAS")]),e._v(" 即为比较并交换，当需要操作数据时需要先拿到主存中的数据进行比较，如果没有其他线程进行修改，就更新自己的数据；否则进行报错或者自旋；"),v("code",[e._v("CAS")]),e._v(" 算法的三个变量：①需要读写的内存值 ②进行比较的值 ③需要写入的新值")]),e._v(" "),v("p",[v("code",[e._v("CAS")]),e._v(" 会导致三个问题：")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aaeecbb348749038dd4ded49110c34f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("ul",[v("li",[v("code",[e._v("ABA")]),e._v(" 问题：就是说 我们对一个变量进行 "),v("code",[e._v("CAS")]),e._v(" 操作的时候，我们以为这个值没有发生变化，但是其实他已经变化了，比如说，值原来是5，后面改成了10，在后面的时候改为了5这样；解决方法有两个：\n"),v("ul",[v("li",[e._v("第一个是才去版本号，进行一次数据操作的时候版本号进行 +1，然后 原来的 A -> B -> C，变成了 1A -> 2B -> 3C；")]),e._v(" "),v("li",[e._v("第二种可以使用这个 "),v("code",[e._v("AtomicStampedReference")]),e._v(" 这个类，他有一个 "),v("code",[e._v("compareAndSet")]),e._v(" 方法首先检查当前对象的引用值是否等于预期引用，并且当前印戳（"),v("code",[e._v("Stamp")]),e._v("）标志是否等于预期标志，如果完全相等，以原子的方式将引用值和印戳标志的值更新给指定的更新值了。")])])]),e._v(" "),v("li",[e._v("自旋时间开销大：如果一个线程长时间获取不到锁，就有可能给 CPU 带来非常大的开销；")]),e._v(" "),v("li",[e._v("只能保证一个共享变量的原子操作：对一个共享变量的时候，"),v("code",[e._v("CAS")]),e._v(" 是可以保证这个原子操作，但是对于多个共享变量来说，"),v("code",[e._v("CAS")]),e._v(" 就没办法保证；解决办法为：\n"),v("ul",[v("li",[e._v("使用 "),v("code",[e._v("AtomicReference")]),e._v(" 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 "),v("code",[e._v("CAS")]),e._v(" 操作")])])])]),e._v(" "),v("p",[e._v("公平锁和非公平锁")]),e._v(" "),v("p",[e._v("公平锁：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中第一个线程才能获取锁；")]),e._v(" "),v("ul",[v("li",[e._v("优点：每个线程都不会被饿死；")]),e._v(" "),v("li",[e._v("缺点：整个系统的吞吐量低，性能不那么好；")])]),e._v(" "),v("p",[e._v("非公平锁："),v("strong",[e._v("多个线程加锁时直接尝试获取锁，获取不到就去等待队列的队尾进行排队等待")]),e._v("；但如果此时锁刚好可用，那么这个线程就会可以无需阻塞直接获取锁，所以"),v("strong",[e._v("非公平锁可能会出现后申请锁的线程获取到锁")]),e._v("的情况；")]),e._v(" "),v("p",[e._v("公平锁示例：")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/a23d746a.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("非公平锁示例：")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/4499559e.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("code",[e._v("ReenTranLock")]),e._v(" 为例：公平锁以及非公平锁的区别：")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bc6fe583.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("而我们深入这个 "),v("code",[e._v("hasQueuedPredecessors()")]),e._v(" 方法看一下：如下图，很明显，公平锁就是多了这个判断，主要是判断"),v("strong",[e._v("当前线程是否位于同步队列中的第一个")]),e._v("，如果是则返回 "),v("code",[e._v("true")]),e._v("，否则返回 "),v("code",[e._v("false")]),e._v("；")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bd0036bb.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("自旋锁：")]),e._v(" "),v("p",[e._v("在了解自旋锁之前，首先我们先要知道，为什么需要自旋锁？")]),e._v(" "),v("p",[e._v("阻塞和唤醒一个线程，是需要 "),v("code",[e._v("OS")]),e._v(" 进行 "),v("code",[e._v("CPU")]),e._v(" 上下文切换的，而这个切换是需要消耗处理器的时间，但是一般来说，锁住的代码块执行时间很短，速度快；所以会出现 "),v("strong",[e._v("执行代码所需要的时间 < "),v("code",[e._v("CPU")]),e._v("上下文切换所需要的时间")]),e._v("，本末倒置了；所以基于这个问题，比如说当两个线程进行抢夺资源（锁）时，如果另一个线程没抢到，就先暂时不要挂起，而是继续使用 "),v("code",[e._v("CPU")]),e._v(" 的执行时间，来看看持有锁的线程是否很快地释放锁；这就是自旋锁的由来；在我们的并发包中，"),v("code",[e._v("Atomic")]),e._v(" 原子类就是通过 "),v("strong",[v("code",[e._v("CAS")]),e._v(" + 自旋")]),e._v(" 的操作进行保证原子性的。")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/83b3f85e.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("但是这个自旋锁也有缺点的：自旋操作虽然避免了线程切换的开销，但是要占用处理时间的；如果被占用的时间很短，自旋等待效果很好，但是很长的时候会浪费处理器（"),v("code",[e._v("CPU")]),e._v("）的资源，所以自旋到一定次数还在等待，那就要挂起这个线程了。")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("可重入锁和非可重入锁：")]),e._v(" "),v("p",[e._v("可重入锁：指一个线程"),v("strong",[e._v("在外层方法")]),e._v("获取锁的时候，再进入"),v("strong",[e._v("内层方法会自动获取该方法的锁")]),e._v("（前提该锁是同一个对象或者同一个 "),v("code",[e._v("class")]),e._v("）；好处就是可以一定程度避免死锁。")]),e._v(" "),v("div",{staticClass:"language-Java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 如果是用lock的话，加几次锁就需要释放几次锁")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Widget")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("synchronized")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("doSomething")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("System")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("out"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("println")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[e._v('"方法1执行..."')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("doOthers")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("synchronized")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("doOthers")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("System")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("out"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("println")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[e._v('"方法2执行..."')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br"),v("span",{staticClass:"line-number"},[e._v("5")]),v("br"),v("span",{staticClass:"line-number"},[e._v("6")]),v("br"),v("span",{staticClass:"line-number"},[e._v("7")]),v("br"),v("span",{staticClass:"line-number"},[e._v("8")]),v("br"),v("span",{staticClass:"line-number"},[e._v("9")]),v("br"),v("span",{staticClass:"line-number"},[e._v("10")]),v("br"),v("span",{staticClass:"line-number"},[e._v("11")]),v("br")])]),v("p",[e._v("非可重入锁：找不到这个对应的类")]),e._v(" "),v("p",[e._v("那就直接看可重入锁即可了：在进行内部加锁的时候会判断当前线程是否还是占有共享变量的线程，如果是则 "),v("code",[e._v("state + 1")]),e._v(" ；在释放的时候也会进行判断当前线程是否是已占有锁的线程，如果是才进行 "),v("code",[e._v("state - 1")]),e._v("，知道 "),v("code",[e._v("state = 0")]),e._v(" 的时候就真正释放锁了")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/32536e7a.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("独占锁和共享锁："),v("code",[e._v("ReentranLock")]),e._v(" 和 "),v("code",[e._v("ReentranReadWriteLock")])]),e._v(" "),v("p",[e._v("重点来说这个 "),v("code",[e._v("ReentranReadWriteLock")]),e._v(" 这个锁，顾名思义：读锁 "),v("code",[e._v("ReadLock")]),e._v(" 则为共享锁；写锁 "),v("code",[e._v("WriteLock")]),e._v(" 就是独占锁，也是排他锁；底层都是 "),v("code",[e._v("Sync")]),e._v(" 这个类来实现的；我们一般用读锁来进行 并发读的操作，并发写的时候只能用 独占锁；读读是可以并发的，但是读写，写读，写写都是互斥的；")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://mltbjl.github.io/blogs/category1/2018/Java%E4%B9%8B%E9%94%81%E7%9A%84%E7%9F%A5%E8%AF%86.html#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81",target:"_blank",rel:"noopener noreferrer"}},[e._v("也可以看看这个关于 Java 锁的文章"),v("OutboundLink")],1),e._v(" 主要是写一些示例 "),v("code",[e._v("demo")])]),e._v(" "),v("p",[e._v("在看我们的读写锁如何实现之前，我们先了解我们的共享变量 "),v("code",[e._v("state")]),e._v(" ，它是一个 "),v("code",[e._v("int")]),e._v(" 整型的 32位的变量，在独占锁中，值一般位0或者1（如果是重入锁的话就是重入的次数）；在共享锁中，代表的就是"),v("strong",[e._v("持有锁的个数")]),e._v("；但是在读写锁中，就将 "),v("code",[e._v("state")]),e._v(" 变量分为高16位和低16位两个维度；高16位表示的是读锁个数，低16位表示写锁个数。")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8793e00a.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("先来看看写锁如何实现的：在 "),v("code",[e._v("tryAcquire()")]),e._v(" 方法中，判断当前是否有读锁以及我们的当前占据锁的线程是否为当前线程；如果是则返回成功否则返回失败；")]),e._v(" "),v("p",[e._v("再来看看读锁如何实现的：在 "),v("code",[e._v("tryAcquireShare()")]),e._v(" 方法中，不说那么多，只需要知道如果当前锁是独占锁，则意味着有线程获取了写锁，需要等待；")]),e._v(" "),v("p",[e._v("轮到我们的 "),v("code",[e._v("ReentranLock")]),e._v("，不论是公平锁还是非公平锁，都是独占锁；因为他都会进行判断：当前线程是否为拥有锁的线程，是才进行 "),v("code",[e._v("state")]),e._v(" 变量的修改，否则返回 "),v("code",[e._v("false")])]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8b7878ec.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("code",[e._v("Synchronized")]),e._v(" 锁升级策略："),v("strong",[e._v("无锁 --\x3e 偏向锁 --\x3e 轻量级锁 --\x3e 重量级锁")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://pic3.zhimg.com/v2-cb859e116b95743c8f28cf41cfd8ee02_b.jpg",alt:"锁（synchronized）升级过程（java） - 知乎"}})]),e._v(" "),v("p",[e._v("主要是跟 对象内存中的对象头有关系，然后还跟我们的 "),v("code",[e._v("Minitor")]),e._v(" 有关系")]),e._v(" "),v("p",[e._v("无锁开始，所有的线程都可以访问共享资源，但同时只有一个线程可以修改成功；无锁的特点就是在一个循环内不断尝试修改这个共享资源，"),v("code",[e._v("CAS")]),e._v(" 应用就是无锁策略；但是无锁没办法代替有锁，但无锁在某些场景性能还是很高的；")]),e._v(" "),v("p",[e._v("偏向锁，即该对象锁总是被一个线程占有，该对象头里记录了该线程的 "),v("code",[e._v("ThreadId")]),e._v(" ；在线程进入和退出同步块时不再通过 "),v("code",[e._v("CAS")]),e._v(" 操作进行加锁和解锁，而是检测 "),v("code",[e._v("Mark Word")]),e._v(" 里是否含有存储着指向当前线程的偏向锁。"),v("strong",[e._v("引入偏向锁的目的是为了减少不必要的轻量级执行路径")]),e._v("，因为轻量级锁的获取以及释放依赖多次的 "),v("code",[e._v("CAS")]),e._v(" 原子指令；而偏向锁只需要在置换 "),v("code",[e._v("ThreadId")]),e._v(" 的时候依赖一次 "),v("code",[e._v("CAS")]),e._v(" 原子指令操作；偏向锁只有遇到竞争线程的时候，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁，而是等到一个全局的安全点（就是没有字节码运行的时候），它会暂停拥有偏向锁的线程，判断锁对象是否还是处于锁定状态，撤销锁后恢复到"),v("strong",[e._v("无锁")]),e._v("或者"),v("strong",[e._v("轻量级锁")]),e._v("状态。")]),e._v(" "),v("p",[e._v("轻量级锁，当对象锁是偏向锁时，如果有其他线程来竞争，偏向锁就会升级为轻量级锁，其他线程不会被阻塞，而是进行自旋尝试获取锁，从而提高性能，问题是偏向锁如何升级到轻量级锁呢？我们的虚拟机会给我们当前线程栈帧（存在我们的栈中）中生成一个锁空间（"),v("code",[e._v("Lock Record")]),e._v("），然后将对象的 "),v("code",[e._v("Mark Word")]),e._v(" 拷贝到我们栈帧中的锁记录中，"),v("strong",[e._v("成功之后")]),e._v("，尝试使用 "),v("code",[e._v("CAS")]),e._v(" 操作将对象的 "),v("code",[e._v("Mark Word")]),e._v(" 更新为指向 "),v("code",[e._v("Lock Record")]),e._v(" 的指针，并将锁记录中的 "),v("code",[e._v("Owner")]),e._v(" 指针指向对象的 "),v("code",[e._v("Mark Word")]),e._v("；这个动作成功之后，"),v("code",[e._v("Mark Word")]),e._v(" 的锁标记也需要改变为 00，表示此时处于轻量级锁状态；如果是失败的话，虚拟机会首先检查对象的 "),v("code",[e._v("Mark Word")]),e._v(" 是否还是指向我们当前的线程，如果是则代表当前线程持有该轻量级锁，则继续进行同步块操作，否则就说明出现竞争锁；")]),e._v(" "),v("p",[e._v("当一个线程持有锁，另一个线程不断地自旋，当自旋到一定次数的时候，或者说，有第三个线程参与竞争的时候，轻量级锁就升级为重量级锁；")]),e._v(" "),v("p",[e._v("升级为重量级锁，"),v("code",[e._v("Mark Word")]),e._v(" 的标记位就会变成 10，此时 "),v("code",[e._v("Mark Word")]),e._v(" 存储的是指向重量级锁的指针，此时等待的线程就会进入阻塞状态。")]),e._v(" "),v("p",[v("strong",[e._v("综上：")])]),e._v(" "),v("p",[e._v("偏向锁是通过对比 Mark Word 解决锁的问题，避免了 "),v("code",[e._v("CAS")]),e._v(" 操作导致的多次的原子指令；轻量级锁则是通过 "),v("code",[e._v("CAS")]),e._v(" + 自旋操作避免线程被挂起；重量级锁将除了拥有锁的其他线程挂起；")]),e._v(" "),v("p",[e._v("死锁问题如何解决？")]),e._v(" "),v("ul",[v("li",[e._v("jps - l 查看运行的 Java 进程；")]),e._v(" "),v("li",[e._v("使用 jstack 查看线程堆栈信息：jstack - l 进程id")])]),e._v(" "),v("p",[v("code",[e._v("AQS(AbstractQueuedSynchronizer)")]),e._v(" 抽象同步队列了解吗？")]),e._v(" "),v("h2",{attrs:{id:"volatile"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[e._v("#")]),e._v(" volatile")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("了解 volatile 之前需要了解 Java 的 JMM 即 Java 内存模型、")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8b7878ec.png",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("这个图片是一个双核 CPU 系统架构，每个核有自己的控制器和运算器，"),v("strong",[e._v("控制器包含一组寄存器和操作控制器")]),e._v("， "),v("strong",[e._v("运行器执行算数运算逻辑")]),e._v("，"),v("strong",[e._v("每个核都有自己的一级缓存")]),e._v("，有些架构里面还有一个所有 CPU 共享的二级缓存。Java 内存模型中的工作内存，对应就是一级缓存或者是二级缓存。")]),e._v(" "),v("p",[e._v("JMM 定义了线程和主内存的关系：线程之间的共享变量存储在我们的主内存中，每个线程都有自己的一个独立的本地内存，本地内存存储了该线程以读\\写共享变量的副本（线程操作的地方就是本地内存嘛）。")])]),e._v(" "),v("li",[v("p",[e._v("JMM 的核心三大特性：原子性；可见性；有序性")]),e._v(" "),v("p",[e._v("原子性：")]),e._v(" "),v("p",[e._v("可见性：一个线程修改了某一个共享变量的值时，其他线程会立刻知道这个修改")]),e._v(" "),v("p",[e._v("有序性：有序性指的是一个线程执行代码，从前往后依次执行")]),e._v(" "),v("p",[e._v("如何保证呢？")]),e._v(" "),v("p",[e._v("原子性可以通过 "),v("code",[e._v("sychronized")]),e._v(" 来进行保证，可见性是通过 "),v("code",[e._v("volatile")]),e._v(" 或者 "),v("code",[e._v("final")]),e._v(" 或者 "),v("code",[e._v("synchronized")]),e._v(" 来进行保证，有序性通过 "),v("code",[e._v("synchronized")]),e._v(" 或者 "),v("code",[e._v("volatile")]),e._v(" 来进行保证的。")])]),e._v(" "),v("li",[v("p",[e._v("什么是指令重排？")]),e._v(" "),v("p",[e._v("线程在执行指令的时候，为了提高性能，编译器和处理器会对指令进行重排序；")]),e._v(" "),v("p",[e._v("就拿 "),v("strong",[e._v("双重校验锁的单例模式")]),e._v(" 来说，"),v("code",[e._v("Instance instance = new Instance();")]),e._v(" 这个步骤，执行过程如下：给"),v("strong",[e._v("对象分配内存空间 ===》初始化对象 ===》 将对象指针指向内存空间")])]),e._v(" "),v("p",[e._v("但是经过这个编译器重排序有可能导致这个第二步和第三步会发生重排序问题。")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfbc542e669c4b00ab9183fdd972202b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)])]),e._v(" "),v("li",[v("p",[e._v("指令重排有啥限制？happens - before 了解吗")])]),e._v(" "),v("li",[v("p",[e._v("volatile 实现原理")]),e._v(" "),v("p",[e._v("volatile 主要是 【有序性】和【可见性】")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("可见性  "),v("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c165afdd7cc486eaad347d80a795600~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("当一个变量被声明为 volatile 时，线程写入变量时不会把值存在寄存器或者其他地方，而是把值刷新回主内存，当其他线程到读取这个变量的时候不会从自己的工作内存去读，而是去主内存中重新获取。")])]),e._v(" "),v("li",[v("p",[e._v("有序性 "),v("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/000fe341396e4410aa28367c553f481c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1),e._v(" "),v("a",{attrs:{href:"https://img-blog.csdnimg.cn/6f08878ff57a427e99608f21c01e5bfe.jpeg",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("重排序分为编译器重排序和处理器重排序，volatile 保证有序性，就是通过分别限制这两种类型的重排序嘛。然后拿 volatile 来举例子即可。")])])])])]),e._v(" "),v("h2",{attrs:{id:"多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[e._v("#")]),e._v(" 多线程")]),e._v(" "),v("p",[e._v("并发和并行的区别")]),e._v(" "),v("p",[e._v("实现多线程的方式")]),e._v(" "),v("h2",{attrs:{id:"线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[e._v("#")]),e._v(" 线程池")]),e._v(" "),v("p",[e._v("核心参数：")]),e._v(" "),v("p",[e._v("执行流程：")]),e._v(" "),v("p",[e._v("阻塞队列种类：")]),e._v(" "),v("p",[e._v("拒绝策略种类：① "),v("code",[e._v("AboryPolicy")]),e._v(" 默认是拒绝新的任务，然后抛出异常；② "),v("code",[e._v("DiscardPolicy")]),e._v("：拒绝新的任务，但是不抛出异常；③ "),v("code",[e._v("CallRunsPolicy")]),e._v("：那些线程提交的任务，就由哪一个线程进行处理；④ "),v("code",[e._v("DiscardOldestPolicy")]),e._v("：丢弃最前面的任务；")]),e._v(" "),v("p",[e._v("IO 密集型 和 CPU 密集型如何选择计算：")]),e._v(" "),v("p",[e._v("CPU密集型："),v("code",[e._v("cpu + 1")]),e._v("；IO密集型："),v("code",[e._v("cpu * 2")])]),e._v(" "),v("p",[e._v("为什么是这样计算呢？")]),e._v(" "),v("p",[e._v("CPU 密集型是由于计算任务占据主要的 CPU 资源，我们通常将 CPU 数量 + 1来进行充分使用多核处理能力，这样做的目的是避免 CPU 资源饱和，保持任务的高效运行；")]),e._v(" "),v("p",[e._v("IO 密集型主要的任务消耗在我们的 IO 操作上，CPU 的利用率相对很低，这种情况下，为了更好利用 CPU 资源，可以提高这个 CPU 数来提高任务的并发处理能力；目的是在等待 IO 操作完成的过程中，可以并行处理其他任务，从而减少等待时间，提高系统的吞吐量。")]),e._v(" "),v("h2",{attrs:{id:"synchronized-和-reentranlock-对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-和-reentranlock-对比"}},[e._v("#")]),e._v(" Synchronized 和 ReentranLock 对比")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75cc232c973e4ef89f8c8cdb75a2952c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[e._v("图片"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("区别：")]),e._v(" "),v("ul",[v("li",[e._v("一个是 "),v("code",[e._v("JVM")]),e._v(" 层面的锁，一个是 "),v("code",[e._v("API")]),e._v(" 层面的锁；")]),e._v(" "),v("li",[v("code",[e._v("Synchronized")]),e._v(" 锁底层是基于 Monitor 对象锁进行实现的，这个 "),v("code",[e._v("Monitor")]),e._v(" 是底层是基于 "),v("code",[e._v("Metux Lock")]),e._v(" 互斥锁实现的；"),v("code",[e._v("ReentranLock")]),e._v("基于这个 "),v("code",[e._v("AQS")]),e._v(" 框架实现的；")]),e._v(" "),v("li",[v("code",[e._v("Synchronized")]),e._v(" 一般可以作用于方法上，静态方法上，以及代码块；"),v("code",[e._v("ReentranLock")]),e._v(" 一般都是作用在代码块上的，然后需要手动释放锁，而且也可以设置一个锁的过期时间；")]),e._v(" "),v("li",[e._v("两者都是非公平锁（"),v("code",[e._v("ReentranLock")]),e._v(" 默认是）；都是可重入锁；")]),e._v(" "),v("li",[v("code",[e._v("synchronized")]),e._v(" 不够灵活，"),v("code",[e._v("ReentranLock")]),e._v(" 灵活，提供了锁中断、锁精准通知、锁超时等功能。")])]),e._v(" "),v("h2",{attrs:{id:"并发集合类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发集合类"}},[e._v("#")]),e._v(" 并发集合类")]),e._v(" "),v("p",[v("code",[e._v("HashTable")]),e._v(" 了解一下")]),e._v(" "),v("p",[v("code",[e._v("ConcurrentHashMap")]),e._v(" 的 "),v("code",[e._v("put()")]),e._v(" 执行流程、"),v("code",[e._v("get()")]),e._v(" 执行流程；"),v("code",[e._v("key")]),e._v(" 和 "),v("code",[e._v("value")]),e._v(" 为什么不可以是 "),v("code",[e._v("null")]),e._v("？")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("put()")]),e._v(" 流程：首先根据 "),v("code",[e._v("key")]),e._v(" 计算哈希值 ---- 》然后循环遍历桶数组，如果当前数组为空，则进行初始化（"),v("code",[e._v("CAS")]),e._v(" 操作进行扩容）----》 如果当前索引指向的位置为空，则进行 "),v("code",[e._v("CAS")]),e._v(" 操作插入节点（无需加锁的桶数组）----》 如果当前桶被标记为迁移状态（"),v("code",[e._v("MOVED")]),e._v("），则帮助进行迁移 ----》 对当前 "),v("code",[e._v("Node")]),e._v(" 节点进行锁定，确认并发情况下的线程安全 ----》 然后开始遍历节点，如果 "),v("code",[e._v("key")]),e._v(" 相同则进行替换 "),v("code",[e._v("value")]),e._v("，如果遍历到尾部了还是没有对应的 "),v("code",[e._v("key")]),e._v(" 就需要进行尾插法进行添加元素。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("get()")]),e._v(" 流程：不需要加锁，但是前提桶数组不能为空；"),v("code",[e._v("get()")]),e._v(" 方法是采用了 "),v("code",[e._v("unsafe")]),e._v(" 类也就是 "),v("code",[e._v("CAS")]),e._v(" 机制来保证获取到的元素是最新的；即采用了 "),v("code",[e._v("volatile")]),e._v(" 来修饰 "),v("code",[e._v("table")]),e._v(" 桶数组来保证集合的可见，来保证线程安全；")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("key")]),e._v(" 和 "),v("code",[e._v("value")]),e._v(" 为什么不能为空："),v("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1690271",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考这篇博客"),v("OutboundLink")],1)])]),e._v(" "),v("li",[v("p",[e._v("为什么使用了 "),v("code",[e._v("CAS")]),e._v(" 还需要使用 "),v("code",[e._v("Synchronized")]),e._v("？"),v("a",{attrs:{href:"https://juejin.cn/post/7147678463942459399",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考这篇博客"),v("OutboundLink")],1)])])]),e._v(" "),v("p",[v("code",[e._v("CopyOnWriteArrayList")]),e._v(" 的 add() 流程")]),e._v(" "),v("h2",{attrs:{id:"锁优化策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁优化策略"}},[e._v("#")]),e._v(" 锁优化策略")]),e._v(" "),v("p",[e._v("如何减少锁的粒度？")]),e._v(" "),v("h2",{attrs:{id:"无锁胜有锁-空间换时间-threadlocal"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#无锁胜有锁-空间换时间-threadlocal"}},[e._v("#")]),e._v(" 无锁胜有锁，空间换时间 ThreadLocal")]),e._v(" "),v("p",[e._v("底层如何保证高并发？")]),e._v(" "),v("p",[e._v("如何避免出现内存泄漏？")]),e._v(" "),v("p",[e._v("为什么 key 要继承弱引用？")])])}),[],!1,null,null,null);v.default=a.exports}}]);