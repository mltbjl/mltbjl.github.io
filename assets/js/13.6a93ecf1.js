(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{401:function(v,_,e){"use strict";e.r(_);var t=e(2),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("本文参考 "),_("a",{attrs:{href:"https://juejin.cn/post/7056769257937305636#heading-23",target:"_blank",rel:"noopener noreferrer"}},[v._v("三分恶"),_("OutboundLink")],1),v._v(" ，打算记录一些平时容易忘记的 "),_("code",[v._v("Java")]),v._v(" 八股文")]),v._v(" "),_("h2",{attrs:{id:"成员变量与局部变量的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#成员变量与局部变量的区别"}},[v._v("#")]),v._v(" 成员变量与局部变量的区别？")]),v._v(" "),_("p",[v._v("这里我想了解的是 "),_("strong",[v._v("变量在内存中的存储方式如何")]),v._v("？")]),v._v(" "),_("p",[v._v("首先我们要知道 成员变量可以被 public、static、private等修饰符修饰，而局部变量不可以被访问修饰符比如说 public 和 static 修饰符修饰，但是都是可以被这个 final 修饰的；所以说，如果被 static 修饰的成员变量是属于类的，如果没有用 static 修饰，就是属于实例的，而我们又知道，这个"),_("strong",[v._v("类的信息是存储在我们的 方法区中的")]),v._v("，我们的"),_("strong",[v._v("实例对象信息是存储在我们的 堆内存中的")]),v._v("；而这个"),_("strong",[v._v("局部变量存储在我们的 栈内存")]),v._v("中；")]),v._v(" "),_("h2",{attrs:{id:"final-关键字的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#final-关键字的作用"}},[v._v("#")]),v._v(" final 关键字的作用")]),v._v(" "),_("ul",[_("li",[v._v("修饰在类上，类不可以被继承（String）")]),v._v(" "),_("li",[v._v("修饰在方法上，方法不可以被重写")]),v._v(" "),_("li",[v._v("修饰在变量上，变量的引用不可以变化；且必须要显式指定初始值。这里的"),_("strong",[v._v("不可以变化指的是变量的引用不可变，不是引用指向的内容不可以变化。")])])]),v._v(" "),_("p",[_("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26d927ab84ba4660aface0bf83516e26~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[v._v("图片展示"),_("OutboundLink")],1)]),v._v(" "),_("h2",{attrs:{id:"和-equals-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#和-equals-的区别"}},[v._v("#")]),v._v(" == 和 equals 的区别")]),v._v(" "),_("p",[v._v("==：作用是判断两个对象是否相等，即判断对象是否是同一个对象（如果是 "),_("strong",[v._v("基本数据类型")]),v._v("，比较的是值；如果是 "),_("strong",[v._v("引用类型")]),v._v("，比较的是 内存地址）")]),v._v(" "),_("p",[_("code",[v._v("equals")]),v._v("：第一种情况：没有重写 "),_("code",[v._v("equals()")]),v._v(" 方法，就是等同于 == ；如果是重写了，就是比较对象中的值是否相同；")]),v._v(" "),_("p",[v._v("那问题来了，你重写过 "),_("code",[v._v("hashcode")]),v._v(" 和 "),_("code",[v._v("equals")]),v._v(" 么，为什么重写 "),_("code",[v._v("equals")]),v._v(" 时必须重写 "),_("code",[v._v("hashCode")]),v._v(" ⽅法？")]),v._v(" "),_("p",[v._v("我们首先要了解什么是 "),_("code",[v._v("hashCode")]),v._v("，"),_("code",[v._v("Java")]),v._v(" 中的 "),_("code",[v._v("hashCode")]),v._v(" 是一个 Object 类的本地方法，通常都是将对象的内存地址转换为整数后进行返回。")]),v._v(" "),_("p",[v._v("如果两个对象相等，则 "),_("code",[v._v("hashcode")]),v._v(" 一定相等，两个对象相等，对两个对象进行调用 "),_("code",[v._v("equals")]),v._v(" 方法都返回 "),_("code",[v._v("true")]),v._v("，反之，两个对象有相同的 "),_("code",[v._v("hashcode")]),v._v(" 值，不一定回相等，"),_("code",[v._v("hash")]),v._v(" 碰撞嘛。因此，"),_("strong",[v._v("equals")]),v._v(" ⽅法被覆盖过，则 "),_("strong",[v._v("hashCode")]),v._v(" ⽅法也必须被覆盖。")]),v._v(" "),_("p",[_("code",[v._v("hashcode()")]),v._v(" 方法默认行为是对堆上的对象产生独特值，如果没有重写 "),_("code",[v._v("hashCode()")]),v._v(" ，则该 "),_("code",[v._v("class")]),v._v(" 的两个对象无论如何都不会相等。")]),v._v(" "),_("h2",{attrs:{id:"深拷贝-浅拷贝"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝-浅拷贝"}},[v._v("#")]),v._v(" 深拷贝 & 浅拷贝")]),v._v(" "),_("p",[v._v("首先两者都是创建对象的一种方式；")]),v._v(" "),_("ul",[_("li",[v._v("浅拷贝：仅拷贝对象成员变量的值")]),v._v(" "),_("li",[v._v("深拷贝：不仅对象成员变量的值会改变，同时也将引用变量指向堆中的实例也会拷贝")])]),v._v(" "),_("p",[_("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/215dcf998061455594343c682c568e4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[v._v("图片展示"),_("OutboundLink")],1)]),v._v(" "),_("p",[v._v("也可以记住这个图，深拷贝是安全的，浅拷贝的话如果你修改了引用类型，会影响原对象；")]),v._v(" "),_("p",[v._v("浅拷贝可以使用我们的 "),_("code",[v._v("Object")]),v._v(" 类中的 "),_("code",[v._v("clone()")]),v._v(" 方法；")]),v._v(" "),_("p",[v._v("深拷贝就需要重写我们的克隆方法，引用类型变量单独克隆，可能会涉及到多重递归；当然也可以进行序列化和反序列化；")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0bbb427d2064de0baae5e14dea9d397~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[v._v("图片展示"),_("OutboundLink")],1)]),v._v(" "),_("ul",[_("li",[_("code",[v._v("new")]),v._v(" 创建新对象")]),v._v(" "),_("li",[v._v("通过反射机制")]),v._v(" "),_("li",[v._v("采用 "),_("code",[v._v("clone")]),v._v(" 机制")]),v._v(" "),_("li",[v._v("通过序列化机制")])]),v._v(" "),_("h2",{attrs:{id:"string是不是基本数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#string是不是基本数据类型"}},[v._v("#")]),v._v(" String是不是基本数据类型？")]),v._v(" "),_("p",[_("code",[v._v("String")]),v._v(" 是一个比较特殊的引用类型；")]),v._v(" "),_("h2",{attrs:{id:"string、stringbuilder、stringbuffer区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#string、stringbuilder、stringbuffer区别"}},[v._v("#")]),v._v(" String、StringBuilder、StringBuffer区别")]),v._v(" "),_("p",[_("code",[v._v("String")]),v._v("："),_("code",[v._v("String")]),v._v(" 的值创建后不可以被修改，任何对 "),_("code",[v._v("String")]),v._v(" 的修改都是会产生一个新的对象值，"),_("code",[v._v("String")]),v._v(" 有很多 "),_("code",[v._v("API")]),v._v("，比如说 切割方法、分割方法、长度方法等；")]),v._v(" "),_("p",[_("code",[v._v("StringBuffer")]),v._v("：跟 "),_("code",[v._v("String")]),v._v(" 相似，但是值可以被修改，底层是使用这个 "),_("code",[v._v("synchronized")]),v._v(" 来保证线程安全的；")]),v._v(" "),_("p",[_("code",[v._v("StringBuilder")]),v._v("："),_("code",[v._v("StringBuffer")]),v._v(" 的非线程安全版，性能上更好一些；")]),v._v(" "),_("h2",{attrs:{id:"intern-方法有什么作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#intern-方法有什么作用"}},[v._v("#")]),v._v(" intern 方法有什么作用")]),v._v(" "),_("p",[v._v("官方解释：如果"),_("strong",[v._v("字符串内容")]),v._v("（这里十分要注意！！！是字符串内容）存在于常量池（即 "),_("code",[v._v("equals()")]),v._v(" 方法也为"),_("code",[v._v("true")]),v._v("，也是内容一样），直接"),_("strong",[v._v("返回字符串常量池中的字符串")]),v._v("即可；否则就需要将此 "),_("code",[v._v("String")]),v._v(" 对象添加到池中，并返回 "),_("code",[v._v("String")]),v._v(" 对象的引用。")]),v._v(" "),_("h2",{attrs:{id:"object-类中常用的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#object-类中常用的方法"}},[v._v("#")]),v._v(" Object 类中常用的方法")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa9a4530641f41fab74c712e8c6d8910~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[v._v("图片展示"),_("OutboundLink")],1)]),v._v(" "),_("h2",{attrs:{id:"反射"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[v._v("#")]),v._v(" 反射")]),v._v(" "),_("p",[v._v("我们创建对象都是通过 new 来进行获取的，编译时候就确定了这个类型信息；")]),v._v(" "),_("p",[v._v("反射就是"),_("strong",[v._v("动态地获取一个类的信息、创建类的实例对象、调用类方法")]),v._v("这时候就需要用到反射了；")]),v._v(" "),_("p",[v._v("反射最核心的四个类：")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d5ea9b1efe6427996a16c43ad2d3170~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp",target:"_blank",rel:"noopener noreferrer"}},[v._v("图片展示"),_("OutboundLink")],1)]),v._v(" "),_("ul",[_("li",[v._v("应用场景？")])]),v._v(" "),_("p",[v._v("比如说我们的 "),_("code",[v._v("Spring")]),v._v(" 的时候，一个 "),_("code",[v._v("@Component")]),v._v(" 注解就可以声明一个 Bean 对象，通过一个 "),_("code",[v._v("@Value")]),v._v(" 就可以获取配置文件的值，就是因为反射操作，然后到类/属性/方法/方法的参数上的注解，注解这里就有两个作用，一是标记，我们对注解标记的类/属性/方法进行对应的处理；二是注解本身有一些信息，可以参与到处理的逻辑中。")]),v._v(" "),_("ul",[_("li",[v._v("反射原理")])]),v._v(" "),_("p",[v._v("我们知道 "),_("code",[v._v("Java")]),v._v(" 程序的执行分为编译和运行两步，编译之后会生成字节码（"),_("code",[v._v(".class")]),v._v("）文件，"),_("code",[v._v("JVM")]),v._v(" 进行类加载的时候，会加载字节码文件，然后将相关的所有信息加载到我们的方法区中，反射就是去方法区中获取到这样的信息然后进行操作的。")])])}),[],!1,null,null,null);_.default=r.exports}}]);